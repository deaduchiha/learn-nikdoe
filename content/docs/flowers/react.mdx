---
title: ری‌اکت بخش ۱ — مقدمه
description: بیاموزید ری‌اکت چیست، چه فناوری‌هایی پشت آن است و پشت‌صحنه چگونه کار می‌کند.
---

## 1 · ری‌اکت چیست؟

ری‌اکت یک **کتابخانهٔ جاوااسکریپت** برای ساخت رابط‌های کاربری است.  
به شما کمک می‌کند برای وب‌سایت‌ها و وب‌اپ‌ها رابط‌های کاربری سریع و تعاملی بسازید.  
ری‌اکت را مثل لگو برای وب در نظر بگیرید: قطعات را به هم وصل می‌کنید تا چیزهای بزرگ بسازید.

- **کتابخانه** است، نه یک فریم‌ورک کامل — آزادی انتخاب و کنار هم گذاشتن ابزارها دست شماست. [بیشتر: کتابخانه در برابر فریم‌ورک →](/docs/flowers/library-vs-framework)
- ساختهٔ **فیسبوک (متا)** در سال ۲۰۱۳ برای حل پیچیدگی رابط کاربری در مقیاس بالا.

> **چرا محبوب است:** اجزای قابل‌استفادهٔ مجدد، به‌روزرسانی‌های سریع، جامعهٔ قدرتمند، و پشتیبانی از وب **و** موبایل (React Native).

---

## 2 · فناوری‌هایی که ری‌اکت به‌کار می‌گیرد

| لایه       | فناوری                          | وظیفه‌اش چیست                                                |
| ---------- | ------------------------------- | ------------------------------------------------------------ |
| زبان       | **JavaScript (ES6 +)**          | دستور زبان مدرن مثل `import`، `class` و توابع پیکانی         |
| نگارش      | **JSX**                         | اجازه می‌دهد داخل JS کدی شبیه HTML بنویسید                   |
| ترنس‌پایلر | **Babel**                       | JSX و JS مدرن را به کدی تبدیل می‌کند که همهٔ مرورگرها بفهمند |
| باندلر     | **Vite / esbuild** (یا Webpack) | همهٔ فایل‌ها را در یک باندل بهینه به هم می‌چسباند            |
| زمان‌اجرا  | **React DOM**                   | ری‌اکت را به DOM واقعی مرورگر وصل می‌کند                     |
| زمان‌بند   | **Fiber**                       | کارهای بزرگ را قطعه‌قطعه می‌کند تا صفحه روان بماند           |
| رویدادها   | **سامانهٔ رویداد مصنوعی**       | یک شنوندهٔ هوشمند به‌جای چندین شنوندهٔ بومی                  |

---

## 3 · ری‌اکت پشت‌صحنه چگونه کار می‌کند

در این بخش، چرخهٔ رندر را به‌صورت مرحله‌به‌مرحله، ساختاریافته و قابل‌درک توضیح می‌دهیم.

---

## 🔹 مرحلهٔ ۱: نوشتن JSX

JSX خودش جاوااسکریپت معتبر نیست — مرورگر مستقیم آن را متوجه نمی‌شود.

```jsx
const element = <h1>Hello React!</h1>;
```

---

## 🔄 مرحلهٔ ۲: بابل JSX را به جاوااسکریپت تبدیل می‌کند

بابل JSX را به فراخوانی‌های معمولی تابع تبدیل می‌کند (مثل `React.createElement`) تا مرورگر بتواند بفهمد چه باید بسازد.

---

## 🌳 مرحلهٔ ۳: ساخت درخت Virtual DOM

به‌جای لمس‌کردن مستقیم DOM واقعی (که هزینه‌بر است)، ری‌اکت یک نمایش سبک از رابط کاربری به‌صورت **درختی از اشیا** می‌سازد — چیزی که به آن **Virtual DOM** می‌گوییم.

---

## 🧮 مرحلهٔ ۴: محاسبهٔ تفاوت‌ها (Diffing)

ری‌اکت نسخهٔ قبلی و جدید درخت را مقایسه می‌کند تا **کمترین تغییرات لازم** برای رسیدن به وضعیت جدید را پیدا کند.

---

## 🧱 مرحلهٔ ۵: ری‌کانسیلیشن (آشتی‌دادن)

بر اساس تفاوت‌ها، ری‌اکت تصمیم می‌گیرد کدام گره‌ها ایجاد/به‌روزرسانی/حذف شوند — بدون نیاز به بازسازی همه‌چیز.

---

## ⏱️ مرحلهٔ ۶: زمان‌بندی با Fiber

موتور **Fiber** در ری‌اکت به‌روزرسانی‌ها را به قطعات کوچکی به‌نام **واحدهای کار** تقسیم می‌کند.

این قطعات:

- در **زمان‌هایIdle** زمان‌بندی می‌شوند،
- بر اساس اهمیت **اولویت‌بندی** می‌شوند،
- و در طول زمان پخش می‌شوند تا **اسکرول و انیمیشن‌ها روان** بمانند.

این همان **رندر هم‌زمان (concurrent rendering)** است.

---

## ✅ مرحلهٔ ۸: اِعمال تغییرات DOM

در نهایت، ری‌اکت با استفاده از **APIهای استاندارد DOM** تغییرات را اِعمال می‌کند:

```js
element.textContent = "Hello World!";
```

ری‌اکت این کار را:

- با **حداقل** دستکاری DOM،
- به‌صورت **غیرهم‌زمان**،
- و با **ترتیب بهینه** انجام می‌دهد.

---

## 🔁 جریان دیداری

```
JSX
▼
Babel → React.createElement()
▼
Virtual DOM Tree
▼
Diff (Old vs New)
▼
Reconciliation (what to add/update/remove)
▼
Commit to Real DOM
```

---

## 4 · یک «مینی‌ری‌اکت» ۲۰ خطی برای درک شهودی

کد زیر یک نسخهٔ **بسیار کوچک و آموزشی** از ایدهٔ اصلی ری‌اکت است (برای تولید مناسب نیست!)؛ هدف صرفاً روشن کردن مفهوم **Virtual DOM** و **رندر درختی** است:

```js
// 1. ایجاد "element"
function h(type, props, ...children) {
  return { type, props: props || {}, children };
}

/**
 * یک «گرهٔ مجازی» را به DOM واقعی تبدیل کن و داخل یک والد قرار بده.
 * @param {Object|string} node   گرهٔ مجازی یا متن ساده.
 * @param {HTMLElement}   parent عنصر DOM والد که محتوای جدید را دریافت می‌کند.
 */
function render(node, parent) {
  // اگر مقدار متنی است، یک TextNode بساز و اضافه کن، سپس تمام.
  if (typeof node === "string") {
    parent.appendChild(document.createTextNode(node));
    return;
  }

  // 2️⃣ ساخت یک عنصر واقعی DOM مثل <div>، <button> و...
  const el = document.createElement(node.type);

  // 3️⃣ کپی‌کردن هر پراپ (className، onclick و...) روی عنصر جدید
  Object.entries(node.props).forEach(([k, v]) => (el[k] = v));

  // 4️⃣ پیمایش همهٔ فرزندان، تخت‌کردن آرایه‌های تو‌در‌تو، و رندر آن‌ها
  node.children.flat().forEach((child) => render(child, el));

  // 5️⃣ پس از آماده‌شدن همهٔ فرزندان، این عنصر را به والدش اضافه کن
  parent.appendChild(el);
}

// استفاده
const tree = h(
  "ul",
  { className: "list" },
  h("li", null, "🍎 Apple"),
  h("li", null, "🍊 Orange")
);

render(tree, document.getElementById("root"));
```

این نسخهٔ خیلی کوچک:

- یک درخت از اشیای جاوااسکریپتی می‌سازد (**Virtual DOM** ما).
- درخت را پیمایش می‌کند و نودهای واقعی DOM ایجاد می‌کند.
- هر بار **کامل** رندر می‌کند (فعلاً بدون Diffing).

> دیدن نسخهٔ ساده باعث می‌شود ری‌اکت از ابهام دربیاید؛ در زیرِ پوسته، صرفاً جاوااسکریپتی است که باهوشانه DOM را دستکاری می‌کند.

---

## 5 · تمرین خانگی 🏡

1. **بازی با Virtual DOM**

   - کد _مینی‌ری‌اکت_ را در یک فایل HTML خالی کپی کنید.
   - دکمه‌ای اضافه کنید که فهرست را با یک میوهٔ اضافه دوباره رندر کند. به **پرش یا چشمک** توجه کنید (چون رندر کامل است). تصور کنید الگوریتم Diffing چگونه می‌تواند آن را بهبود دهد.

2. **توضیح ری‌اکت برای یک دوست**

   - در پنج جمله توضیح دهید _چرا_ ری‌اکت وجود دارد و _چه مشکلی_ را حل می‌کند.

```

اگر دوست دارید، می‌توانم همین متن را به‌صورت فایل `react.fa.mdx` برای دانلود تحویلتان بدهم یا آن را راست‌به‌چپ (RTL) با استایل مناسب آماده کنم. فقط بگویید کدام را ترجیح می‌دهید.
```
