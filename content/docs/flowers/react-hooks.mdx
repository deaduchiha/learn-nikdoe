---
title: React 19 Hooks Cookbook
description: A practical, example‑driven reference to every official React 19 hook with best practices and hands‑on exercises.
---

# React 19 Hooks

> **What are Hooks?** Hooks are just JavaScript functions whose names start with `use*`. They let you “hook into” React features from function components.

---

## 1. Fundamental hooks

These hooks cover most day‑to‑day needs.

### 1.1 `useState`

Imagine your component is a **piggy bank** 🐷 that keeps a number inside it.
`useState` gives you **two things**:

1. The **current number** in the piggy bank (`count`).
2. A **friendly robot** called `setCount` that can change that number.

Two ways to tell the robot what to do:

| Way                  | What you say           | What it means                                                                                  |
| -------------------- | ---------------------- | ---------------------------------------------------------------------------------------------- |
| **Direct value**     | `setCount(count + 1)`  | “Hey robot, write THIS exact number into the piggy bank.”                                      |
| **Updater function** | `setCount(c => c + 1)` | “Hey robot, when you get the piggy bank, add 1 to whatever number is in there **right then**.” |

Why the second way is safer:

- **The robot works from a queue.** If you yell instructions twice very quickly, both direct-value orders might be based on the _same_ starting number. The updater form makes the robot re-check the piggy bank each time.
- **React sometimes waits** (it “batches”) before letting the robot work. During that wait, the number can change. The updater form guarantees you don’t lose those changes.

> **Rule of thumb:**
> Any time the **new value depends on the old value**, use the updater form.

---

Tiny example: a **Double Click** button:

```tsx
import { useState } from "react";

export default function DoubleClick() {
  const [count, setCount] = useState(0); // 0 is our initial value

  const handleClick = () => {
    // We want +2 each click
    setCount((c) => c + 1);
    setCount((c) => c + 1);
  };

  return <button onClick={handleClick}>You clicked {count} times</button>;
}
```

- Click once → **2**
- Click again → **4**
  If we had used `setCount(count + 1)` twice, we’d only get **1 → 2 → 3 …** (because both calls use the same stale `count`).

---

This is an example for Controlled inputs with useState:

```tsx
const [query, setQuery] = useState<string>(""); // what happened if we set undefined as initial value ?

<input
  className="border p-1 rounded-sm"
  type="text"
  onChange={(e) => {
    setQuery(e.target.value.replace(/koala/gi, "🐨"));
  }}
/>;
```

---

Best-practice cheatsheet:

1. **Keep state small.** Store _only_ what you can’t compute.
2. **Use functional (updater) form** when the new value depends on the old.
3. **Group related updates** in one call:

   ```tsx
   setUser((u) => ({ ...u, age: u.age + 1 }));
   ```

4. **Don’t read state right after calling `setX`.** It hasn’t updated yet.
5. **For very complex state** (lots of fields), consider `useReducer`.

---

Homework 🏠

1. **Single-step counter**

   - Build `Stepper.tsx`.
   - Start at **0**.
   - Add **+1**, **−1**, and **Reset** buttons.
   - Use the updater form for +1 and −1.

2. **Time machine counter**

   - Add another button **“+5”** that loops five times with the updater form

     ```tsx
     for (let i = 0; i < 5; i++) {
       setCount((c) => c + 1);
     }
     ```

   - Prove to yourself that it jumps by 5 every click.

3. **Explain it to a friend** (or rubber duck 🦆)

   - In one short paragraph, describe **why** `setCount(c => c + 1)` is safer than `setCount(count + 1)`.
   - If they can repeat it back, you’ve mastered the concept!

Happy coding — and remember: **tell the robot _how_ to change the value, not _what_ value to write.**

- [First project in class - My Library](/docs/projects/hooks/use-state/first)
- [Second project in class - Pet list](/docs/projects/hooks/use-state/second)

---

Here is a complete, **step‑by‑step teaching guide** for `useReducer` in React, written as if I’m teaching a beginner from zero knowledge — with clear explanation, best practices, real‑world examples (beginner, intermediate, advanced), and a homework at the end.

---

### 1.2 `useReducer`

---

#### 1.2.1 What is `useReducer`?

When your component’s state becomes **too complex for `useState`**, you need something better to organize your logic.

✅ `useReducer` lets you write **predictable state transitions** using a reducer function.
✅ You “dispatch” an action, and the reducer calculates the new state.
✅ This is very similar to Redux, but built into React.

---

#### 1.2.2 Syntax

```tsx
const [state, dispatch] = useReducer(reducer, initialArg, init?);
```

| Term         | Meaning                                   |
| ------------ | ----------------------------------------- |
| `state`      | current state                             |
| `dispatch`   | function you call to trigger a change     |
| `reducer`    | pure function that decides the next state |
| `initialArg` | initial state                             |
| `init`       | optional lazy initializer                 |

---

#### 1.2.3 When to use it?

- When you have **complex state logic**, e.g., an object or multiple values.
- When the **next state depends on the previous state**.
- When you want to **centralize state updates**, like a mini‑Redux.

---

#### 1.2.4 Beginner Example — Counter

This is the most classic and simplest example.

```tsx
type Action = { type: "inc" } | { type: "dec" } | { type: "reset" };

function reducer(state: number, action: Action) {
  switch (action.type) {
    case "inc":
      return state + 1;
    case "dec":
      return state - 1;
    case "reset":
      return 0;
    default:
      return state;
  }
}

function Counter() {
  const [count, dispatch] = useReducer(reducer, 0);

  return (
    <>
      <p>{count}</p>
      <button onClick={() => dispatch({ type: "inc" })}>+</button>
      <button onClick={() => dispatch({ type: "dec" })}>−</button>
      <button onClick={() => dispatch({ type: "reset" })}>Reset</button>
    </>
  );
}
```

📝 Notes:

- `reducer` is a **pure function** → it takes `state` & `action` → returns **new state**.
- `dispatch` sends an action.

---

#### 1.2.5 Best Practices

✅ Keep the reducer **pure** → No API calls, no timers, no side effects.
✅ Always handle **all actions**.
✅ Co‑locate the reducer with the component unless shared.
✅ Use TypeScript to ensure exhaustive action handling.
✅ Do not mutate the state — always return a **new copy**.

---

#### 1.2.6 Real‑world Examples

- **Beginner** — `Toggle theme`

```tsx
type ThemeAction = { type: "light" } | { type: "dark" };

function themeReducer(state: "light" | "dark", action: ThemeAction) {
  switch (action.type) {
    case "light":
      return "light";
    case "dark":
      return "dark";
    default:
      return state;
  }
}

function ThemeToggle() {
  const [theme, dispatch] = useReducer(themeReducer, "light");

  return (
    <div>
      <p>Current theme: {theme}</p>
      <button onClick={() => dispatch({ type: "light" })}>Light</button>
      <button onClick={() => dispatch({ type: "dark" })}>Dark</button>
    </div>
  );
}
```

---

- **Intermediate** — `Form State`

Suppose you’re managing a form with multiple fields:

```tsx
type FormState = { name: string; email: string };
type FormAction =
  | { type: "setName"; payload: string }
  | { type: "setEmail"; payload: string }
  | { type: "reset" };

function formReducer(state: FormState, action: FormAction): FormState {
  switch (action.type) {
    case "setName":
      return { ...state, name: action.payload };
    case "setEmail":
      return { ...state, email: action.payload };
    case "reset":
      return { name: "", email: "" };
    default:
      return state;
  }
}

function MyForm() {
  const [state, dispatch] = useReducer(formReducer, {
    name: "",
    email: "",
  });

  return (
    <form>
      <input
        value={state.name}
        onChange={(e) => dispatch({ type: "setName", payload: e.target.value })}
        placeholder="Name"
      />
      <input
        value={state.email}
        onChange={(e) =>
          dispatch({ type: "setEmail", payload: e.target.value })
        }
        placeholder="Email"
      />
      <button type="button" onClick={() => dispatch({ type: "reset" })}>
        Reset
      </button>
    </form>
  );
}
```

---

- **Advanced** — `Shopping Cart`

Imagine an e‑commerce cart where you can add, remove, or clear items.

```tsx
type Item = { id: number; name: string };
type CartAction =
  | { type: "add"; item: Item }
  | { type: "remove"; id: number }
  | { type: "clear" };

function cartReducer(state: Item[], action: CartAction): Item[] {
  switch (action.type) {
    case "add":
      return [...state, action.item];
    case "remove":
      return state.filter((item) => item.id !== action.id);
    case "clear":
      return [];
    default:
      return state;
  }
}

function Cart() {
  const [cart, dispatch] = useReducer(cartReducer, []);

  return (
    <div>
      <button
        onClick={() =>
          dispatch({ type: "add", item: { id: Date.now(), name: "Apple" } })
        }
      >
        Add Apple
      </button>
      <button onClick={() => dispatch({ type: "clear" })}>Clear</button>
      <ul>
        {cart.map((item) => (
          <li key={item.id}>
            {item.name}{" "}
            <button onClick={() => dispatch({ type: "remove", id: item.id })}>
              Remove
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

---

#### 1.2.7 Homework

Here are some real‑world exercises for you to practice.

- Beginner

  ✅ Build a **theme toggle** with `light | dark | system` using `useReducer`.
  ✅ Render 3 buttons to switch between these modes.

- Intermediate

  ✅ Build a **stepper form** (like multi‑step signup).

  ✅ Use `useReducer` to track which step the user is on, and the form data.

- Advanced

  ✅ Build a **to‑do list app**:

      - Add a task
      - Toggle completed
      - Delete a task
      - Clear all completed

Use `useReducer` for state management.

---

#### 1.2.8 Recap

- `useReducer` is like a mini‑Redux for a single component.
- Great for **complex or dependent state**.
- State transitions are predictable and testable.
- Always keep your reducer pure!

---

````mdx
### 1.3 `useContext`

```ts
const value = useContext(MyContext);
```
````

**When to use**

- Passing data deeply without prop-drilling: theme, i18n, user, settings.
- Sharing global or app-level state: authenticated user, feature flags.
- Avoiding cumbersome prop chains across many intermediate components.

---

### 1.3 `useContext`

**What is Context ?** React Context lets you share a value (any JavaScript data) through your component tree without having to pass props manually at every level. The `useContext` hook is the simplest way to consume that shared value in a functional component.

---

#### 1.3.1 Step‐by‐Step Guide

1. **Create a Context**

   ```ts
   import { createContext } from "react";

   export const MyContext = createContext<ContextType>(defaultValue);
   ```

   - **Type parameter**: define what shape the context value has.
   - **defaultValue**: used only when no matching Provider is above.

2. **Provide the Context**

   ```tsx
   import { MyContext } from "./MyContext";

   function App() {
     const sharedValue: ContextType = {
       /* … */
     };

     return (
       <MyContext.Provider value={sharedValue}>
         <YourComponentTree />
       </MyContext.Provider>
     );
   }
   ```

   - Wrap the parts of your tree that need access.

3. **Consume with `useContext`**

   ```tsx
   import { useContext } from "react";
   import { MyContext } from "./MyContext";

   function Child() {
     const ctx = useContext(MyContext);
     return <div>{/* use ctx here */}</div>;
   }
   ```

4. **Optional: Create a Custom Hook**
   Encapsulate logic & improve DX:

   ```ts
   export function useMyContext() {
     const ctx = useContext(MyContext);
     if (ctx === undefined) {
       throw new Error("useMyContext must be used within a MyContext.Provider");
     }
     return ctx;
   }
   ```

---

#### 1.3.2 Best Practices

- **Avoid Churn for Frequent Updates**

  - Don’t put rapidly changing data (e.g. scroll position) in context—use props or local state.

- **Split Contexts by Concern**

  - Instead of one “mega‐context,” create separate contexts for theme, auth, settings.

- **Type Safely**

  - Always provide a well‐typed default or guard in a custom hook.

---

#### 1.3.3 Real‐World Examples

- Beginner: Theme Toggle

  ```tsx
  // theme-context.tsx
  import { createContext, useContext, useState } from "react";

  type Theme = "light" | "dark";
  const ThemeContext = createContext<{
    theme: Theme;
    toggle: () => void;
  }>({ theme: "light", toggle: () => {} });

  export function ThemeProvider({ children }: { children: React.ReactNode }) {
    const [theme, setTheme] = useState<Theme>("light");
    const toggle = () => setTheme((t) => (t === "light" ? "dark" : "light"));

    return (
      <ThemeContext.Provider value={{ theme, toggle }}>
        {children}
      </ThemeContext.Provider>
    );
  }

  export function useTheme() {
    return useContext(ThemeContext);
  }

  // App.tsx
  import { ThemeProvider, useTheme } from "./theme-context";

  function Toolbar() {
    const { theme, toggle } = useTheme();
    return (
      <button className={theme} onClick={toggle}>
        Toggle to {theme === "light" ? "dark" : "light"}
      </button>
    );
  }

  export default function App() {
    return (
      <ThemeProvider>
        <Toolbar />
      </ThemeProvider>
    );
  }
  ```

---

- Intermediate: Language Switcher

  ```tsx
  // language-context.tsx
  import { createContext, useContext, useState } from "react";

  type Lang = "en" | "fa";
  const LanguageContext = createContext<{
    lang: Lang;
    setLang: (l: Lang) => void;
  }>({ lang: "en", setLang: () => {} });

  export function LanguageProvider({
    children,
  }: {
    children: React.ReactNode;
  }) {
    const [lang, setLang] = useState<Lang>("en");
    return (
      <LanguageContext.Provider value={{ lang, setLang }}>
        {children}
      </LanguageContext.Provider>
    );
  }

  export function useLanguage() {
    return useContext(LanguageContext);
  }

  // Greeting.tsx
  import { useLanguage } from "./language-context";

  export function Greeting() {
    const { lang } = useLanguage();
    return <h1>{lang === "en" ? "Hello" : "سلام"}</h1>;
  }

  // Usage in App.tsx
  import { LanguageProvider } from "./language-context";
  import { Greeting } from "./Greeting";

  function App() {
    return (
      <LanguageProvider>
        <Greeting />
        {/* Add a selector somewhere */}
      </LanguageProvider>
    );
  }
  ```

---

- Advanced: Auth + Data Fetching + Memo

```tsx
// auth-context.tsx
import { createContext, useContext, useReducer, ReactNode } from "react";

interface User {
  id: string;
  name: string;
}

type State = { user: User | null };
type Action = { type: "LOGIN"; payload: User } | { type: "LOGOUT" };

const initialState: State = { user: null };

function authReducer(state: State, action: Action): State {
  switch (action.type) {
    case "LOGIN":
      return { user: action.payload };
    case "LOGOUT":
      return { user: null };
    default:
      return state;
  }
}

interface AuthContextType {
  user: User | null;
  login: (u: User) => void;
  logout: () => void;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: ReactNode }) {
  const [state, dispatch] = useReducer(authReducer, initialState);

  const login = (u: User) => {
    dispatch({ type: "LOGIN", payload: u });
  };

  const logout = () => {
    dispatch({ type: "LOGOUT" });
  };

  return (
    <AuthContext.Provider value={{ user: state.user, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const ctx = useContext(AuthContext);
  if (!ctx) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return ctx;
}
```

---

#### 1.3.4 Homework

1. **Beginner**

   - Create a `CounterContext` that holds a number and an `increment()` function.
   - Consume it in two sibling components: one displays the count, the other has a button to increment.

2. **Intermediate**

   - Extend the **Language Switcher**: add a dropdown to pick `en | fa | es`, update `Greeting` to handle all three, and persist selection in `localStorage`.

3. **Advanced**

   - Build an **AuthFlow**:

     1. Create `AuthContext` with `login`, `logout`, `user`.
     2. On login, fetch a user profile from a mock API.
     3. Protect certain routes (use React Router).
     4. Ensure `AuthContext` value is memoized.
     5. Add a custom hook `useRequireAuth` that redirects if not authenticated.

---

### 1.4 `useRef`

```ts
const ref = useRef<T | null>(initialValue);
```

**When to use**

- Persist a mutable value **without** causing re‑renders.
- Direct DOM access.

**Example – Focus input**

```tsx
const inputRef = useRef<HTMLInputElement>(null);

function FocusInput() {
  return (
    <>
      <input ref={inputRef} />
      <button onClick={() => inputRef.current?.focus()}>Focus</button>
    </>
  );
}
```

**Best practices**

- Prefer state for things that drive render.
- Initialize with `null` and specify the type.

**Exercise – Scroll to top**

> Attach a ref to a `<div>` containing long content and make a **Scroll to top** button that calls `ref.current?.scrollTo({ top: 0 })`.

---

### 1.5 `useEffect`

```ts
useEffect(effect, deps?);
```

**When to use**

- Synchronize with external systems: fetch, subscriptions, timers.

**Example – Fetch data**

```tsx
function User({ id }: { id: string }) {
  const [user, setUser] = useState<User | null>(null);

  useEffect(() => {
    let ignore = false;
    fetch(`/api/users/${id}`)
      .then((r) => r.json())
      .then((data) => !ignore && setUser(data));
    return () => {
      ignore = true;
    };
  }, [id]);

  return user ? <pre>{JSON.stringify(user, null, 2)}</pre> : "Loading…";
}
```

**Best practices**

- **Declare every dependency**; rely on ESLint‑react‑hooks.
- Cleanup side effects in the return function.
- Split unrelated concerns into multiple effects.

**Exercise – GitHub profile**

> Fetch `https://api.github.com/users/{username}` when the `username` prop changes and display the avatar.

---

### 1.6 `useLayoutEffect`

Runs **synchronously** after DOM mutations but **before** the browser paints.

**When to use**

- Measuring layout (e.g. element size) **before** the user sees flicker.

**Example – Measure height**

```tsx
const boxRef = useRef<HTMLDivElement>(null);
const [height, setHeight] = useState(0);

useLayoutEffect(() => {
  if (boxRef.current) {
    setHeight(boxRef.current.getBoundingClientRect().height);
  }
}, []);
```

**Exercise – Sticky header**

> Measure a header’s height and add that value as top padding to the main content so it never hides behind the header.

---

### 1.7 `useInsertionEffect`

```ts
useInsertionEffect(effect, deps?);
```

**Purpose**

Inject critical styles **before** layout and paint, avoiding FOUC (flash of unstyled content).

**Example – Dynamic CSS**

```tsx
useInsertionEffect(() => {
  const styleTag = document.createElement("style");
  styleTag.textContent = ".brand { color: tomato; }";
  document.head.append(styleTag);
  return () => styleTag.remove();
}, []);
```

**Exercise**

> Create a component that picks a random accent color on mount and injects a rule like `.accent { color: <color>; }`.

---

### 1.8 `useCallback` & 1.9 `useMemo`

- `useCallback(fn, deps)` returns a **memoized function**.
- `useMemo(factory, deps)` returns a **memoized value**.

**When to use**

- Prevent expensive re‑computations / re‑creations that cause child re‑renders.

**Example – Stable handlers**

```tsx
const addTodo = useCallback((text: string) => {
  setTodos((t) => [...t, { id: crypto.randomUUID(), text }]);
}, []);
```

**Best practices**

- Reach for them **after** verifying perf issues.
- Keep dependency arrays small by lifting stable values up.

**Exercise – Fibonacci viewer**

> Show the `n`th Fibonacci number where `n` comes from an input. Memoize the calculation so it only runs when `n` changes.

---

### 1.10 `useImperativeHandle`

```ts
useImperativeHandle(ref, createHandle, deps?);
```

**Purpose**

Expose a controlled subset of imperative methods to parent components.

**Example – Custom input API**

```tsx
const FancyInput = forwardRef<HTMLInputElement, Props>((props, ref) => {
  const innerRef = useRef<HTMLInputElement>(null);
  useImperativeHandle(ref, () => ({
    focus: () => innerRef.current?.focus(),
    clear: () => innerRef.current && (innerRef.current.value = ""),
  }));
  return <input ref={innerRef} {...props} />;
});
```

**Exercise**

> Build a `Stopwatch` component with `start()`, `stop()`, `reset()` methods exposed via `useImperativeHandle`.

---

### 1.11 `useDebugValue`

Add labels visible in React DevTools.

```ts
useDebugValue(value, formatFn?);
```

Example:

```ts
useDebugValue(user, (u) => `User: ${u.name}`);
```

---

## <a id="additional">2. Additional hooks</a>

### 2.1 `useId`

Generate unique IDs that match between server and client.

```ts
const id = useId();
<label htmlFor={id}>Name</label>
<input id={id} />
```

### 2.2 `useSyncExternalStore`

Subscribe to an external store with consistency during concurrent rendering.

```tsx
const time = useSyncExternalStore(subscribe, getSnapshot);
```

### 2.3 `useDeferredValue`

Defer a non‑urgent value until the browser is idle.

```tsx
const deferred = useDeferredValue(value);
```

**Exercise – Filter list**

> Defer the search query so the list UI stays responsive for long inputs.

### 2.4 `useTransition`

Start a low‑priority transition.

```ts
const [isPending, startTransition] = useTransition();
```

Example – Type‑ahead search that doesn’t lock the UI.

---

## <a id="react19">3. New in React 19</a>

React 19 focuses on **forms** and **data‑mutations**, introducing three new hooks plus the new `use()` function.

### 3.1 `useOptimistic`

Optimistically update the UI **before** the server confirms.

```tsx
const [optimisticTodos, addOptimisticTodo] = useOptimistic<Todo[], Todo>(
  todos,
  (state, newTodo) => [...state, { ...newTodo, optimistic: true }]
);

async function handleAdd(text: string) {
  addOptimisticTodo({ id: "temp", text });
  await saveTodo(text);
}
```

**Exercise – Chat input**

> Show messages instantly with an _optimistic_ label, then replace once saved.

### 3.2 `useActionState`

Handle form `action`s and update component state with the result.

```tsx
const [error, formAction, pending] = useActionState(async (prev, formData) => {
  try {
    await submit(formData);
    return null; // no error
  } catch (e) {
    return (e as Error).message;
  }
}, null);

<form action={formAction}>{/* inputs */}</form>;
```

**Exercise – Rename profile**

> Build a profile rename form that reports server‑side errors through `error`.

### 3.3 `useFormStatus`

Read status of the closest parent `<form>`.

```tsx
const { pending } = useFormStatus();
<button disabled={pending}>Save</button>;
```

**Exercise – Disable on submit**

> In the rename form above, disable the submit button while `pending` is true.

### 3.4 `use()`

Although not technically a hook, `use()` lets you _await_ promises inside a component during rendering.

```tsx
function User({ id }: { id: string }) {
  const user = use(fetch(`/api/users/${id}`).then((r) => r.json()));
  return <span>{user.name}</span>;
}
```

**Caveats**

- Only supported in **Server Components** or with the React compiler.
- Throws a promise under the hood – rely on Suspense boundaries.

---

## <a id="glossary">4. Glossary & further resources</a>

- [React 19 release post](https://react.dev/blog/2024/12/05/react-19)
- [Official Hooks API reference](https://react.dev/reference/react)
- [Kent C. Dodds – Epic React](https://epicreact.dev/) – deep‑dives & exercises
- [React Docs – Forms & Actions](https://react.dev/learn/forms)

---

Made with ❤️ and [Fumadocs](https://fumadocs.org).
