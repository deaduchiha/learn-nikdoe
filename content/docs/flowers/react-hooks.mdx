---
title: کتاب آشپزی هوک‌های React 19
description: مرجع عملی و مثال‌محور برای تمام هوک‌های رسمی React 19 با بهترین شیوه‌ها و تمرینات عملی.
---

# هوک‌های React 19

> **هوک‌ها چیستند؟** هوک‌ها فقط توابع JavaScript هستند که نامشان با `use*` شروع می‌شود. آن‌ها به شما اجازه می‌دهند تا به ویژگی‌های React از کامپوننت‌های تابعی "متصل شوید".

---

## ۱. هوک‌های بنیادی

این هوک‌ها بیشتر نیازهای روزانه را پوشش می‌دهند.

### ۱.۱ `useState`

تصور کنید کامپوننت شما یک **کوزه پس‌انداز** 🐷 است که یک عدد را درون خود نگه می‌دارد.
`useState` به شما **دو چیز** می‌دهد:

۱. **عدد فعلی** در کوزه پس‌انداز (`count`).
۲. یک **ربات دوستانه** به نام `setCount` که می‌تواند آن عدد را تغییر دهد.

دو راه برای گفتن به ربات که چه کاری انجام دهد:

| راه                  | آنچه می‌گویید          | معنای آن                                                                                               |
| -------------------- | ---------------------- | ------------------------------------------------------------------------------------------------------ |
| **مقدار مستقیم**     | `setCount(count + 1)`  | "هی ربات، این عدد دقیق را در کوزه پس‌انداز بنویس."                                                     |
| **تابع به‌روزرسانی** | `setCount(c => c + 1)` | "هی ربات، وقتی کوزه پس‌انداز را می‌گیری، ۱ را به هر عددی که در آنجا **درست در آن لحظه** است اضافه کن." |

چرا راه دوم امن‌تر است:

- **ربات از صف کار می‌کند.** اگر شما دستورات را دو بار خیلی سریع فریاد بزنید، هر دو دستور مقدار مستقیم ممکن است بر اساس همان عدد شروع باشند. فرم به‌روزرسانی باعث می‌شود ربات هر بار کوزه پس‌انداز را دوباره بررسی کند.
- **React گاهی منتظر می‌ماند** (آن را "دسته‌بندی" می‌کند) قبل از اینکه به ربات اجازه کار دهد. در طول آن انتظار، عدد می‌تواند تغییر کند. فرم به‌روزرسانی تضمین می‌کند که شما آن تغییرات را از دست ندهید.

> **قاعده کلی:**
> هر زمان که **مقدار جدید به مقدار قدیمی بستگی دارد**، از فرم به‌روزرسانی استفاده کنید.

---

مثال کوچک: یک دکمه **کلیک دوبل**:

```tsx
import { useState } from "react";

export default function DoubleClick() {
  const [count, setCount] = useState(0); // ۰ مقدار اولیه ما است

  const handleClick = () => {
    // ما می‌خواهیم هر کلیک +۲ باشد
    setCount((c) => c + 1);
    setCount((c) => c + 1);
  };

  return <button onClick={handleClick}>شما {count} بار کلیک کردید</button>;
}
```

- یک بار کلیک کنید → **۲**
- دوباره کلیک کنید → **۴**
  اگر ما از `setCount(count + 1)` دو بار استفاده کرده بودیم، فقط **۱ → ۲ → ۳ …** می‌گرفتیم (چون هر دو فراخوانی از همان `count` قدیمی استفاده می‌کنند).

---

این یک مثال برای ورودی‌های کنترل شده با useState است:

```tsx
const [query, setQuery] = useState<string>(""); // اگر undefined را به عنوان مقدار اولیه تنظیم کنیم چه اتفاقی می‌افتد؟

<input
  className="border p-1 rounded-sm"
  type="text"
  onChange={(e) => {
    setQuery(e.target.value.replace(/koala/gi, "🐨"));
  }}
/>;
```

---

راهنمای بهترین شیوه‌ها:

۱. **حالت را کوچک نگه دارید.** فقط آنچه را که نمی‌توانید محاسبه کنید ذخیره کنید.
۲. **از فرم تابعی (به‌روزرسانی) استفاده کنید** وقتی مقدار جدید به مقدار قدیمی بستگی دارد.
۳. **به‌روزرسانی‌های مرتبط را گروه‌بندی کنید** در یک فراخوانی:

```tsx
setUser((u) => ({ ...u, age: u.age + 1 }));
```

۴. **بلافاصله پس از فراخوانی `setX` حالت را نخوانید.** هنوز به‌روزرسانی نشده است.
۵. **برای حالت بسیار پیچیده** (تعداد زیادی فیلد)، `useReducer` را در نظر بگیرید.

---

تمرین خانگی 🏠

۱. **شمارنده تک‌مرحله‌ای**

- `Stepper.tsx` را بسازید.
- از **۰** شروع کنید.
- دکمه‌های **+۱**، **−۱**، و **بازنشانی** را اضافه کنید.
- از فرم به‌روزرسانی برای +۱ و −۱ استفاده کنید.

۲. **شمارنده ماشین زمان**

- دکمه دیگری **"+۵"** اضافه کنید که پنج بار با فرم به‌روزرسانی حلقه می‌زند

  ```tsx
  for (let i = 0; i < 5; i++) {
    setCount((c) => c + 1);
  }
  ```

- ثابت کنید که هر کلیک ۵ واحد می‌پرد.

۳. **آن را برای یک دوست توضیح دهید** (یا اردک لاستیکی 🦆)

- در یک پاراگراف کوتاه، توضیح دهید که **چرا** `setCount(c => c + 1)` از `setCount(count + 1)` امن‌تر است.
- اگر آن‌ها بتوانند آن را تکرار کنند، شما مفهوم را تسلط یافته‌اید!

کدگذاری شاد — و به یاد داشته باشید: **به ربات بگویید _چگونه_ مقدار را تغییر دهد، نه _چه_ مقداری بنویسد.**

- [اولین پروژه در کلاس - کتابخانه من](/docs/projects/hooks/use-state/first)
- [دومین پروژه در کلاس - لیست حیوانات خانگی](/docs/projects/hooks/use-state/second)

---

در اینجا یک **راهنمای آموزشی گام به گام** برای `useReducer` در React وجود دارد، نوشته شده به گونه‌ای که گویی من یک مبتدی را از دانش صفر آموزش می‌دهم — با توضیح واضح، بهترین شیوه‌ها، مثال‌های دنیای واقعی (مبتدی، متوسط، پیشرفته)، و یک تمرین خانگی در پایان.

---

### ۱.۲ `useReducer`

#### ۱.۲.۱ useReducer چیست؟

وقتی حالت کامپوننت شما **برای `useState` خیلی پیچیده می‌شود**، شما به چیزی بهتر برای سازماندهی منطق خود نیاز دارید.

✅ `useReducer` به شما اجازه می‌دهد **انتقالات حالت قابل پیش‌بینی** را با استفاده از یک تابع reducer بنویسید.
✅ شما یک "action" را "dispatch" می‌کنید، و reducer حالت جدید را محاسبه می‌کند.
✅ این بسیار شبیه Redux است، اما در React ساخته شده است.

---

#### ۱.۲.۲ نحو

```tsx
const [state, dispatch] = useReducer(reducer, initialArg, init?);
```

| اصطلاح       | معنی                                      |
| ------------ | ----------------------------------------- |
| `state`      | حالت فعلی                                 |
| `dispatch`   | تابعی که برای شروع تغییر فراخوانی می‌کنید |
| `reducer`    | تابع خالصی که حالت بعدی را تصمیم می‌گیرد  |
| `initialArg` | حالت اولیه                                |
| `init`       | مقداردهی اولیه تنبل اختیاری               |

---

#### ۱.۲.۳ چه زمانی از آن استفاده کنیم؟

- وقتی **منطق حالت پیچیده** دارید، مثلاً یک شیء یا چندین مقدار.
- وقتی **حالت بعدی به حالت قبلی بستگی دارد**.
- وقتی می‌خواهید **به‌روزرسانی‌های حالت را متمرکز کنید**، مثل یک Redux کوچک.

---

#### ۱.۲.۴ مثال مبتدی — شمارنده

این کلاسیک‌ترین و ساده‌ترین مثال است.

```tsx
type Action = { type: "inc" } | { type: "dec" } | { type: "reset" };

function reducer(state: number, action: Action) {
  switch (action.type) {
    case "inc":
      return state + 1;
    case "dec":
      return state - 1;
    case "reset":
      return 0;
    default:
      return state;
  }
}

function Counter() {
  const [count, dispatch] = useReducer(reducer, 0);

  return (
    <>
      <p>{count}</p>
      <button onClick={() => dispatch({ type: "inc" })}>+</button>
      <button onClick={() => dispatch({ type: "dec" })}>−</button>
      <button onClick={() => dispatch({ type: "reset" })}>بازنشانی</button>
    </>
  );
}
```

📝 یادداشت‌ها:

- `reducer` یک **تابع خالص** است → حالت `state` و `action` را می‌گیرد → **حالت جدید** را برمی‌گرداند.
- `dispatch` یک action را ارسال می‌کند.

---

#### ۱.۲.۵ بهترین شیوه‌ها

✅ reducer را **خالص** نگه دارید → هیچ فراخوانی API، تایمر، یا اثر جانبی.
✅ همیشه **تمام action ها** را مدیریت کنید.
✅ reducer را با کامپوننت هم‌مکان کنید مگر اینکه مشترک باشد.
✅ از TypeScript استفاده کنید تا مدیریت جامع action تضمین شود.
✅ حالت را تغییر ندهید — همیشه یک **کپی جدید** برگردانید.

---

#### ۱.۲.۶ مثال‌های دنیای واقعی

- **مبتدی** — `تغییر تم\*\*

```tsx
type ThemeAction = { type: "light" } | { type: "dark" };

function themeReducer(state: "light" | "dark", action: ThemeAction) {
  switch (action.type) {
    case "light":
      return "light";
    case "dark":
      return "dark";
    default:
      return state;
  }
}

function ThemeToggle() {
  const [theme, dispatch] = useReducer(themeReducer, "light");

  return (
    <div>
      <p>تم فعلی: {theme}</p>
      <button onClick={() => dispatch({ type: "light" })}>روشن</button>
      <button onClick={() => dispatch({ type: "dark" })}>تاریک</button>
    </div>
  );
}
```

---

- **متوسط** — `حالت فرم`

فرض کنید شما یک فرم با چندین فیلد را مدیریت می‌کنید:

```tsx
type FormState = { name: string; email: string };
type FormAction =
  | { type: "setName"; payload: string }
  | { type: "setEmail"; payload: string }
  | { type: "reset" };

function formReducer(state: FormState, action: FormAction): FormState {
  switch (action.type) {
    case "setName":
      return { ...state, name: action.payload };
    case "setEmail":
      return { ...state, email: action.payload };
    case "reset":
      return { name: "", email: "" };
    default:
      return state;
  }
}

function MyForm() {
  const [state, dispatch] = useReducer(formReducer, {
    name: "",
    email: "",
  });

  return (
    <form>
      <input
        value={state.name}
        onChange={(e) => dispatch({ type: "setName", payload: e.target.value })}
        placeholder="نام"
      />
      <input
        value={state.email}
        onChange={(e) =>
          dispatch({ type: "setEmail", payload: e.target.value })
        }
        placeholder="ایمیل"
      />
      <button type="button" onClick={() => dispatch({ type: "reset" })}>
        بازنشانی
      </button>
    </form>
  );
}
```

---

- **پیشرفته** — `سبد خرید`

یک سبد خرید تجارت الکترونیک را تصور کنید که می‌توانید موارد را اضافه، حذف، یا پاک کنید.

```tsx
type Item = { id: number; name: string };
type CartAction =
  | { type: "add"; item: Item }
  | { type: "remove"; id: number }
  | { type: "clear" };

function cartReducer(state: Item[], action: CartAction): Item[] {
  switch (action.type) {
    case "add":
      return [...state, action.item];
    case "remove":
      return state.filter((item) => item.id !== action.id);
    case "clear":
      return [];
    default:
      return state;
  }
}

function Cart() {
  const [cart, dispatch] = useReducer(cartReducer, []);

  return (
    <div>
      <button
        onClick={() =>
          dispatch({ type: "add", item: { id: Date.now(), name: "سیب" } })
        }
      >
        اضافه کردن سیب
      </button>
      <button onClick={() => dispatch({ type: "clear" })}>پاک کردن</button>
      <ul>
        {cart.map((item) => (
          <li key={item.id}>
            {item.name}{" "}
            <button onClick={() => dispatch({ type: "remove", id: item.id })}>
              حذف
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

---

#### ۱.۲.۷ تمرین خانگی

در اینجا برخی تمرینات دنیای واقعی برای تمرین شما وجود دارد.

- مبتدی

  ✅ یک **تغییر تم** با `light | dark | system` با استفاده از `useReducer` بسازید.
  ✅ ۳ دکمه برای تغییر بین این حالت‌ها رندر کنید.

- متوسط

  ✅ یک **فرم چندمرحله‌ای** بسازید (مثل ثبت‌نام چندمرحله‌ای).

  ✅ از `useReducer` برای پیگیری اینکه کاربر در کدام مرحله است، و داده‌های فرم استفاده کنید.

- پیشرفته

  ✅ یک **اپلیکیشن لیست کارها** بسازید:

      - اضافه کردن یک کار
      - تغییر وضعیت تکمیل شده
      - حذف یک کار
      - پاک کردن همه تکمیل شده‌ها

از `useReducer` برای مدیریت حالت استفاده کنید.

---

#### ۱.۲.۸ خلاصه

- `useReducer` مثل یک Redux کوچک برای یک کامپوننت واحد است.
- عالی برای **حالت پیچیده یا وابسته**.
- انتقالات حالت قابل پیش‌بینی و قابل آزمایش هستند.
- همیشه reducer خود را خالص نگه دارید!

---

### ۱.۳ `useContext`

**Context چیست؟** React Context به شما اجازه می‌دهد یک مقدار (هر داده JavaScript) را از طریق درخت کامپوننت خود بدون اینکه مجبور باشید props را به صورت دستی در هر سطح منتقل کنید، به اشتراک بگذارید. هوک `useContext` ساده‌ترین راه برای مصرف آن مقدار مشترک در یک کامپوننت تابعی است.

---

#### ۱.۳.۱ راهنمای گام به گام

۱. **ایجاد یک Context**

```ts
import { createContext } from "react";

export const MyContext = createContext<ContextType>(defaultValue);
```

- **پارامتر نوع**: شکل مقدار context را تعریف کنید.
- **مقدار پیش‌فرض**: فقط زمانی استفاده می‌شود که هیچ Provider مطابقی در بالا نباشد.

۲. **ارائه Context**

```tsx
import { MyContext } from "./MyContext";

function App() {
  const sharedValue: ContextType = {
    /* … */
  };

  return (
    <MyContext.Provider value={sharedValue}>
      <YourComponentTree />
    </MyContext.Provider>
  );
}
```

- قسمت‌هایی از درخت خود را که نیاز به دسترسی دارند، بپیچید.

۳. **مصرف با `useContext`**

```tsx
import { useContext } from "react";
import { MyContext } from "./MyContext";

function Child() {
  const ctx = useContext(MyContext);
  return <div>{/* از ctx اینجا استفاده کنید */}</div>;
}
```

۴. **اختیاری: ایجاد یک هوک سفارشی**
منطق را کپسوله کنید و DX را بهبود دهید:

```ts
export function useMyContext() {
  const ctx = useContext(MyContext);
  if (ctx === undefined) {
    throw new Error("useMyContext باید درون یک MyContext.Provider استفاده شود");
  }
  return ctx;
}
```

---

#### ۱.۳.۲ بهترین شیوه‌ها

- **از تغییرات مکرر برای به‌روزرسانی‌های سریع جلوگیری کنید**

  - داده‌های سریع‌التغییر (مثل موقعیت اسکرول) را در context قرار ندهید — از props یا حالت محلی استفاده کنید.

- **Context ها را بر اساس نگرانی تقسیم کنید**

  - به جای یک "mega-context"، context های جداگانه برای تم، احراز هویت، تنظیمات ایجاد کنید.

- **به صورت ایمن تایپ کنید**

  - همیشه یک مقدار پیش‌فرض خوب تایپ شده ارائه دهید یا در یک هوک سفارشی محافظت کنید.

---

#### ۱.۳.۳ مثال‌های دنیای واقعی

- مبتدی: تغییر تم

  ```tsx
  // theme-context.tsx
  import { createContext, useContext, useState } from "react";

  type Theme = "light" | "dark";
  const ThemeContext = createContext<{
    theme: Theme;
    toggle: () => void;
  }>({ theme: "light", toggle: () => {} });

  export function ThemeProvider({ children }: { children: React.ReactNode }) {
    const [theme, setTheme] = useState<Theme>("light");
    const toggle = () => setTheme((t) => (t === "light" ? "dark" : "light"));

    return (
      <ThemeContext.Provider value={{ theme, toggle }}>
        {children}
      </ThemeContext.Provider>
    );
  }

  export function useTheme() {
    return useContext(ThemeContext);
  }

  // App.tsx
  import { ThemeProvider, useTheme } from "./theme-context";

  function Toolbar() {
    const { theme, toggle } = useTheme();
    return (
      <button className={theme} onClick={toggle}>
        تغییر به {theme === "light" ? "تاریک" : "روشن"}
      </button>
    );
  }

  export default function App() {
    return (
      <ThemeProvider>
        <Toolbar />
      </ThemeProvider>
    );
  }
  ```

---

- متوسط: تغییردهنده زبان

  ```tsx
  // language-context.tsx
  import { createContext, useContext, useState } from "react";

  type Lang = "en" | "fa";
  const LanguageContext = createContext<{
    lang: Lang;
    setLang: (l: Lang) => void;
  }>({ lang: "en", setLang: () => {} });

  export function LanguageProvider({
    children,
  }: {
    children: React.ReactNode;
  }) {
    const [lang, setLang] = useState<Lang>("en");
    return (
      <LanguageContext.Provider value={{ lang, setLang }}>
        {children}
      </LanguageContext.Provider>
    );
  }

  export function useLanguage() {
    return useContext(LanguageContext);
  }

  // Greeting.tsx
  import { useLanguage } from "./language-context";

  export function Greeting() {
    const { lang } = useLanguage();
    return <h1>{lang === "en" ? "Hello" : "سلام"}</h1>;
  }

  // استفاده در App.tsx
  import { LanguageProvider } from "./language-context";
  import { Greeting } from "./Greeting";

  function App() {
    return (
      <LanguageProvider>
        <Greeting />
        {/* یک انتخاب‌کننده جایی اضافه کنید */}
      </LanguageProvider>
    );
  }
  ```

---

- پیشرفته: احراز هویت + دریافت داده + Memo

```tsx
// auth-context.tsx
import { createContext, useContext, useReducer, ReactNode } from "react";

interface User {
  id: string;
  name: string;
}

type State = { user: User | null };
type Action = { type: "LOGIN"; payload: User } | { type: "LOGOUT" };

const initialState: State = { user: null };

function authReducer(state: State, action: Action): State {
  switch (action.type) {
    case "LOGIN":
      return { user: action.payload };
    case "LOGOUT":
      return { user: null };
    default:
      return state;
  }
}

interface AuthContextType {
  user: User | null;
  login: (u: User) => void;
  logout: () => void;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: ReactNode }) {
  const [state, dispatch] = useReducer(authReducer, initialState);

  const login = (u: User) => {
    dispatch({ type: "LOGIN", payload: u });
  };

  const logout = () => {
    dispatch({ type: "LOGOUT" });
  };

  return (
    <AuthContext.Provider value={{ user: state.user, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const ctx = useContext(AuthContext);
  if (!ctx) {
    throw new Error("useAuth باید درون یک AuthProvider استفاده شود");
  }
  return ctx;
}
```

---

#### ۱.۳.۴ تمرین خانگی

۱. **مبتدی**

- یک `CounterContext` ایجاد کنید که یک عدد و یک تابع `increment()` را نگه می‌دارد.
- آن را در دو کامپوننت هم‌سطح مصرف کنید: یکی تعداد را نمایش می‌دهد، دیگری دکمه‌ای برای افزایش دارد.

۲. **متوسط**

- **تغییردهنده زبان** را گسترش دهید: یک dropdown برای انتخاب `en | fa | es` اضافه کنید، `Greeting` را برای مدیریت هر سه به‌روزرسانی کنید، و انتخاب را در `localStorage` ذخیره کنید.

۳. **پیشرفته**

- یک **AuthFlow** بسازید:

  ۱. `AuthContext` با `login`، `logout`، `user` ایجاد کنید.
  ۲. در ورود، یک پروفایل کاربر از یک API جعلی دریافت کنید.
  ۳. مسیرهای خاصی را محافظت کنید (از React Router استفاده کنید).
  ۴. اطمینان حاصل کنید که مقدار `AuthContext` memoized است.
  ۵. یک هوک سفارشی `useRequireAuth` اضافه کنید که اگر احراز هویت نشده باشد، redirect کند.

---

### ۱.۴ `useRef`

`useRef` یک هوک React است که به شما یک **مقدار قابل تغییر می‌دهد که در طول رندرها باقی می‌ماند اما باعث re-render نمی‌شود وقتی تغییر می‌کند.**

شما همچنین می‌توانید از آن برای گرفتن یک **مرجع به یک عنصر DOM** استفاده کنید، که رایج‌ترین مورد استفاده است.

---

#### ۱.۴.۱ نحو

```tsx
const ref = useRef<T | null>(initialValue);
```

اینجا:

- `T` نوع مقدار است (مثل `HTMLInputElement`، `number`، و غیره).
- `initialValue` معمولاً `null` است اگر با عناصر DOM کار می‌کنید.

---

#### ۱.۴.۲ چه زمانی استفاده کنیم

    ✅ وقتی نیاز دارید:

    - داده **قابل تغییر** را ذخیره کنید که **بر رندر کردن تأثیر نمی‌گذارد**.
    - دسترسی **مستقیم DOM** بگیرید (مثل فوکوس کردن یک ورودی، اسکرول کردن یک div، و غیره).

---

#### ۱.۴.۳ مثال مبتدی – فوکوس ورودی

یک مثال کلاسیک از دسترسی به یک عنصر DOM و فراخوانی متد `.focus()` آن.

```tsx
import { useRef } from "react";

function FocusInput() {
  const inputRef = useRef<HTMLInputElement>(null);

  const handleFocus = () => {
    inputRef.current?.focus();
  };

  return (
    <>
      <input ref={inputRef} />
      <button onClick={handleFocus}>فوکوس</button>
    </>
  );
}

export default FocusInput;
```

    **چه اتفاقی می‌افتد؟**

    ۱️⃣ در اولین رندر، `inputRef.current` برابر `null` است.
    ۲️⃣ پس از اینکه React `<input />` را رندر کرد، گره DOM را به `inputRef.current` اختصاص می‌دهد.
    ۳️⃣ کلیک کردن روی دکمه متد `.focus()` را روی آن گره DOM فراخوانی می‌کند.

---

#### ۱.۴.۴ بهترین شیوه‌ها

✅ از `useRef` استفاده کنید:

- برای دسترسی DOM (`inputRef`، `scrollRef`، و غیره).
- برای **مقادیر قابل تغییر** که نیازی به شروع re-render ندارند.

❌ از `useRef` برای موارد زیر استفاده نکنید:

- حالتی که بر آنچه در UI می‌بینید تأثیر می‌گذارد → به جای آن از `useState` استفاده کنید.

🎯 ref های DOM را با `null` مقداردهی اولیه کنید، و همیشه قبل از استفاده از آن‌ها با optional chaining (`?.`) بررسی کنید.

---

#### ۱.۴.۵ مثال متوسط — اسکرول به بالا

یک صفحه طولانی که می‌توانید به بالای آن اسکرول کنید.

```tsx
import { useRef } from "react";

function ScrollToTop() {
  const containerRef = useRef<HTMLDivElement>(null);

  const handleScrollTop = () => {
    containerRef.current?.scrollTo({ top: 0, behavior: "smooth" });
  };

  return (
    <div>
      <button onClick={handleScrollTop}>اسکرول به بالا</button>
      <div
        ref={containerRef}
        style={{
          height: "200px",
          overflow: "auto",
          border: "1px solid black",
          marginTop: "10px",
        }}
      >
        <div style={{ height: "800px" }}>
          <p>محتوای زیادی اینجا. به اسکرول کردن ادامه دهید...</p>
        </div>
      </div>
    </div>
  );
}

export default ScrollToTop;
```

---

#### ۱.۴.۶ مثال پیشرفته — ذخیره تاریخچه کلیک‌ها بدون Re-render

شما می‌توانید از `useRef` برای ذخیره داده **در طول رندرها** استفاده کنید، حتی اگر روی صفحه نمایش داده نشود، و باعث re-render نمی‌شود.

```tsx
import { useRef, useState } from "react";

function ClickHistory() {
  const [count, setCount] = useState(0);
  const historyRef = useRef<number[]>([]);

  const handleClick = () => {
    setCount((prev) => {
      const newCount = prev + 1;
      historyRef.current.push(newCount); // ذخیره در تاریخچه
      return newCount;
    });
  };

  const showHistory = () => {
    alert(`تاریخچه: ${historyRef.current.join(", ")}`);
  };

  return (
    <>
      <p>تعداد فعلی: {count}</p>
      <button onClick={handleClick}>افزایش</button>
      <button onClick={showHistory}>نمایش تاریخچه</button>
    </>
  );
}

export default ClickHistory;
```

---

چه اتفاقی می‌افتد؟

✅ هر بار که روی **افزایش** کلیک می‌کنید، `count` را افزایش می‌دهیم.
✅ در همان زمان، تعداد جدید را در آرایه `historyRef.current` ذخیره می‌کنیم.
✅ این تاریخچه **باعث** re-render نمی‌شود — فقط یک ذخیره‌سازی آرام است.
✅ وقتی روی **نمایش تاریخچه** فشار می‌دهید، تمام تعدادهای قبلی را نشان می‌دهد.

---

چرا این خوب است:

- شما یاد می‌گیرید که `useRef` چگونه داده را در طول رندرها نگه می‌دارد.
- نیازی به استفاده از `useEffect` ندارید.
- نشان می‌دهد که `useRef` _واکنشی نیست_ — فقط داده را آرام ذخیره می‌کند.

---

سناریوهای دنیای واقعی

✅ فوکوس کردن یک ورودی وقتی یک modal باز می‌شود.
✅ اسکرول کردن یک پنجره چت به پایین وقتی پیام جدیدی می‌رسد.
✅ ذخیره ID های interval یا تایمرها.
✅ اندازه‌گیری ابعاد عنصر با `getBoundingClientRect`.

---

#### ۱.۴.۷ جدول خلاصه

| ویژگی                           | `useRef`                            |
| ------------------------------- | ----------------------------------- |
| باعث رندر می‌شود؟               | ❌ خیر                              |
| عنصر DOM ذخیره می‌کند؟          | ✅ بله                              |
| مقادیر قابل تغییر ذخیره می‌کند؟ | ✅ بله                              |
| بهترین برای حالت UI؟            | ❌ خیر (از `useState` استفاده کنید) |

---

#### ۱.۴.۸ تمرین خانگی

- مبتدی:

  - یک فرم بسازید که کلیک کردن روی دکمه اولین فیلد خالی را فوکوس کند.

- متوسط:

  - یک `div` اسکرول‌شونده با موارد زیاد بسازید و دکمه‌ای برای اسکرول به پایین یا بالا به صورت نرم.

- پیشرفته:

  - کامپوننتی بسازید که موقعیت قبلی و فعلی ماوس را پیگیری کند، موقعیت قبلی را فقط از طریق `useRef` به‌روزرسانی کند.

---

#### ۱.۴.۹ خلاصه

✨ `useRef` عبارت است از:

- راهی برای نگه داشتن یک مقدار پایدار بدون اینکه باعث re-render شود.
- روش اصلی برای دسترسی به گره‌های DOM.

---

### ۱.۵ `useEffect`

#### ۱.۵.۱ اثر جانبی چیست؟

**تعریف**:
در برنامه‌نویسی (به طور خاص React)، یک **اثر جانبی** هر چیزی است که یک تابع انجام می‌دهد که بر چیزی خارج از محدوده فوری خود تابع تأثیر می‌گذارد.

**مثال‌های ساده اثرات جانبی**:

    - دریافت داده از یک سرور.
    - به‌روزرسانی دستی DOM.
    - تنظیم تایمرها (setTimeout، setInterval).
    - اشتراک در رویدادها.
    - ثبت چیزی در کنسول.

**مثال آسان‌فهم**:

تصور کنید به یک دستگاه ATM می‌روید:

- **اثر اصلی**: برداشت پول.
- **اثر جانبی**: بانک برای شما یک پیامک SMS ارسال می‌کند.

کار اصلی برداشت پول بود، اما یک کار اضافی — ارسال SMS — خارج از کار اصلی رخ داد.

---

#### ۱.۵.۲ چرا React به useEffect نیاز دارد؟

کامپوننت‌های React باید خالص و قابل پیش‌بینی باشند. با این حال، برای مقابله با اپلیکیشن‌های دنیای واقعی، گاهی اوقات نیاز به انجام اثرات جانبی مانند دریافت داده، دستکاری DOM، و تایمرها دارید.

**نمودار جریان**:

```
کامپوننت React
       |
       |----> رندر UI (بدون اثرات جانبی!)
       |
       |----> انجام اثرات جانبی پس از رندر (useEffect)
                    |
                    |-- دریافت داده
                    |-- تایمر / فواصل
                    |-- به‌روزرسانی مستقیم DOM
```

---

#### ۱.۵.۳ هوک useEffect در React

React یک هوک داخلی به نام `useEffect` برای مدیریت این اثرات جانبی ارائه می‌دهد.

**نحو**:

```jsx
useEffect(() => {
  // کد اثر جانبی اینجا

  return () => {
    // کد پاکسازی (اختیاری)
  };
}, [dependencies]);
```

**پارامترهای useEffect توضیح داده شده:**

- **تابع اثر**: پس از رندر اجرا می‌شود.
- **آرایه وابستگی**: تعیین می‌کند که چه زمانی اثر اجرا می‌شود.
- **تابع پاکسازی**: اختیاری، قبل از اثر بعدی یا در unmount اجرا می‌شود.

---

#### ۱.۵.۴ نمودار جریان چرخه حیات useEffect

```
کامپوننت Mount می‌شود (اولین رندر)
       |
       |--> useEffect اجرا می‌شود
       |        |
       |        --> اثر جانبی اجرا می‌شود
       |
تغییر حالت یا Props
       |
       |--> React آرایه وابستگی را بررسی می‌کند
                |
                |--> [تغییر کرده؟]
                        |
                        |--> بله: پاکسازی اثر قبلی (اگر وجود دارد)، سپس اثر را دوباره اجرا کن
                        |--> خیر: رد کن
       |
کامپوننت Unmount می‌شود
       |
       |--> پاکسازی اجرا می‌شود (اگر ارائه شده باشد)
```

---

#### ۱.۵.۵ مثال‌های useEffect (مبتدی، متوسط، پیشرفته)

---

- **مثال مبتدی: useEffect ساده**

  فقط "سلام" را وقتی کامپوننت بارگذاری می‌شود ثبت کنید:

  ```jsx
  import { useEffect } from "react";

  function HelloWorld() {
    useEffect(() => {
      console.log("سلام، اثر جانبی!");
    }, []);

    return <h1>سلام دنیا</h1>;
  }
  ```

- **مثال متوسط: دریافت داده**

  دریافت داده از API وقتی کامپوننت برای اولین بار رندر می‌شود:

  ```jsx
  import { useEffect, useState } from "react";

  function UserList() {
    const [users, setUsers] = useState([]);

    useEffect(() => {
      fetch("https://jsonplaceholder.typicode.com/users")
        .then((res) => res.json())
        .then((data) => setUsers(data));
    }, []);

    return (
      <ul>
        {users.map((user) => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
    );
  }
  ```

- **مثال پیشرفته: تایمر با پاکسازی**

  یک تایمر شمارش معکوس که خودش را پاک می‌کند:

  ```jsx
  import { useEffect, useState } from "react";

  function Timer() {
    const [seconds, setSeconds] = useState(10);

    useEffect(() => {
      const timerId = setInterval(() => {
        setSeconds((s) => s - 1);
      }, 1000);

      // پاکسازی interval در unmount
      return () => clearInterval(timerId);
    }, []);

    return <h1>{seconds} ثانیه باقی مانده!</h1>;
  }
  ```

---

#### ۱.۵.۶ بهترین شیوه‌ها

- **وابستگی‌ها:** همیشه به وضوح مشخص کنید. خالی گذاشتن یعنی یک بار در mount اجرا شود.
- **پاکسازی:** همیشه interval ها، اشتراک‌ها را پاک کنید تا از نشت حافظه جلوگیری کنید.
- **تقسیم:** اثرات جانبی غیرمرتبط را در هوک‌های `useEffect` جداگانه برای وضوح تقسیم کنید.

**خوب:**

```jsx
useEffect(() => {
  fetchData();
}, []);
useEffect(() => {
  document.title = "اپ من";
}, [title]);
```

---

#### ۱.۵.۷ تمرین خانگی

**مبتدی:**

- یک کامپوننت React ایجاد کنید که عنوان سند را به "سلام دنیا" یک بار بارگذاری شده با استفاده از `useEffect` به‌روزرسانی کند.

**متوسط:**

- کامپوننتی ایجاد کنید که لیستی از پست‌ها را از `jsonplaceholder.typicode.com/posts` دریافت و نمایش دهد.

**پیشرفته:**

- کامپوننتی ایجاد کنید که به تغییر اندازه پنجره گوش دهد و اندازه فعلی پنجره را نمایش دهد. فراموش نکنید که پاک کنید!

---

#### ۱.۵.۸ **مثال دنیای واقعی: زنگ اعلان**

یک زنگ اعلان 🔔 را تصور کنید که نشان می‌دهد چند پیام جدید دارید.

```jsx
import { useEffect, useState } from "react";

function NotificationBell() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const intervalId = setInterval(() => {
      fetch("https://api.example.com/notifications/unread-count")
        .then((res) => res.json())
        .then((data) => setCount(data.count));
    }, 5000);

    return () => clearInterval(intervalId);
  }, []);

  return <button>🔔 {count}</button>;
}
```

**چه اتفاقی اینجا افتاد؟**

- کامپوننت اعلان‌های نخوانده را هر ۵ ثانیه دریافت می‌کند.
- اگر کامپوننت را ترک کنید یا ببندید، interval را به طور خودکار پاک می‌کند.

---

#### ۱.۵.۹ **نمودار خلاصه (همه با هم):**

```
کامپوننت React
  |
  | رندر
  |
  |---> اثرات جانبی (useEffect)
          |
          |-- دریافت داده
          |-- دستکاری DOM
          |-- گوش‌دهندگان رویداد/اشتراک‌ها
          |
          |--- پاکسازی اختیاری (تابع return)
```

---

📝 **نکات کلیدی**

- اثرات جانبی پس از رندر رخ می‌دهند.
- React `useEffect` را برای مدیریت تمیز این اثرات جانبی ارائه می‌دهد.
- آرایه‌های وابستگی کنترل می‌کنند که چه زمانی اثرات اجرا می‌شوند.
- همیشه پاکسازی کنید تا از باگ‌ها و نشت حافظه جلوگیری کنید.

#### ۱.۵.۱۰ غور عمیق: پاکسازی در useEffect (فاز Unmounting)

- **گام ۱: پاکسازی در React چیست؟**

وقتی اثرات جانبی را در React اجرا می‌کنید، گاهی اوقات نیاز دارید آن‌ها را "پاک کنید" پس از اینکه کارتان تمام شد، به خصوص وقتی کامپوننت **unmount** می‌شود (از صفحه حذف می‌شود).

تابع پاکسازی کمک می‌کند از موارد زیر جلوگیری کنید:

- نشت حافظه
- رفتارهای ناخواسته
- خطاها به دلیل عملیات روی عناصر غیرموجود

---

- **گام ۲: چرخه حیات کامپوننت و پاکسازی**

در اینجا یک نمودار جریان ساده بصری وجود دارد:

```
Mount کامپوننت
     |
     |---- useEffect اجرا می‌شود
     |          |
     |          |---> اثر جانبی شروع شد
     |
به‌روزرسانی کامپوننت (تغییر حالت/props)
     |
     |-- پاکسازی (اگر وابستگی‌ها تغییر کرده باشند)
     |      |
     |      |---> اثر قبلی پاک شد
     |
     |-- اثر دوباره اجرا می‌شود (اگر deps تغییر کرده باشند)
     |
Unmount کامپوننت (کامپوننت ترک می‌کند)
     |
     |-- تابع پاکسازی اجرا می‌شود
            |
            |---> پاکسازی تمام شد
```

**مهم:**

- پاکسازی **قبل از** unmount کامپوننت رخ می‌دهد.
- به React اجازه می‌دهد منابع را به طور مناسب مدیریت کند.

---

- **گام ۳: چه زمانی به پاکسازی نیاز دارید؟**

سناریوهای رایج:

- **گوش‌دهندگان رویداد** (مثل تغییر اندازه، اسکرول)
- **فواصل و تایمرها**
- **اشتراک‌ها** (مثل WebSockets، Redux، Firebase listeners)
- **لغو درخواست‌های HTTP**

---

- **گام ۴: نحو پاکسازی پایه**

```jsx
useEffect(
  () => {
    // اثر جانبی
    console.log("اثر اجرا شد!");

    // تابع پاکسازی
    return () => {
      console.log("پاک شد!");
    };
  },
  [
    /* وابستگی‌ها */
  ]
);
```

- اگر از `useEffect` خود یک تابع برگردانید، React به طور خودکار آن را اجرا می‌کند وقتی:

  - **کامپوننت unmount می‌شود**
  - وابستگی‌ها **تغییر می‌کنند** (اثر قبلی پاک می‌شود، سپس اثر جدید اجرا می‌شود)

---

- **گام ۵: مثال‌های عملی**

  - **مثال مبتدی: پاکسازی با تایمر**

  شمارش ثانیه‌ها:

  ```jsx
  import { useEffect, useState } from "react";

  function Timer() {
    const [count, setCount] = useState(0);

    useEffect(() => {
      const timerId = setInterval(() => {
        setCount((prev) => prev + 1);
      }, 1000);

      // تابع پاکسازی
      return () => clearInterval(timerId);
    }, []);

    return <div>ثانیه‌های گذشته: {count}</div>;
  }
  ```

  **توضیح:**

  - تایمر در mount شروع می‌شود.
  - تایمر در unmount پاک می‌شود تا از نشت حافظه یا به‌روزرسانی حالت در کامپوننت unmounted جلوگیری کند.

---

    - **مثال متوسط: گوش‌دهنده تغییر اندازه پنجره**

    گوش دادن به اندازه پنجره مرورگر:

```jsx
import { useEffect, useState } from "react";

function WindowSize() {
  const [size, setSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight,
  });

  useEffect(() => {
    const handleResize = () => {
      setSize({ width: window.innerWidth, height: window.innerHeight });
    };

    window.addEventListener("resize", handleResize);

    // پاکسازی گوش‌دهنده در unmount
    return () => window.removeEventListener("resize", handleResize);
  }, []);

  return (
    <div>
      اندازه پنجره: {size.width}px x {size.height}px
    </div>
  );
}
```

**توضیح:**

- گوش‌دهنده تغییر اندازه اضافه می‌شود.
- گوش‌دهنده در unmount حذف می‌شود تا از نشت جلوگیری کند.

---

- **مرجع سریع (خلاصه نمودار جریان):**

```
کامپوننت React
       |
       | Mount می‌شود
       |
 useEffect() اثر جانبی شروع می‌شود
       |
       | به‌روزرسانی (تغییر وابستگی)
       |
       +-- پاکسازی اثر قبلی
       +-- اجرای اثر جدید
       |
 Unmount کامپوننت
       |
 پاکسازی اثرات جانبی (پاکسازی نهایی)
```

---

### ۱.۶ `useLayoutEffect`

**به صورت همزمان** پس از تغییرات DOM اما **قبل از** نقاشی مرورگر اجرا می‌شود.

**چه زمانی استفاده کنیم**

- اندازه‌گیری layout (مثل اندازه عنصر) **قبل از** اینکه کاربر فلیکر ببیند.

**مثال – اندازه‌گیری ارتفاع**

```tsx
const boxRef = useRef<HTMLDivElement>(null);
const [height, setHeight] = useState(0);

useLayoutEffect(() => {
  if (boxRef.current) {
    setHeight(boxRef.current.getBoundingClientRect().height);
  }
}, []);
```

**تمرین – هدر چسبان**

> ارتفاع یک هدر را اندازه‌گیری کنید و آن مقدار را به عنوان padding بالایی به محتوای اصلی اضافه کنید تا هرگز پشت هدر پنهان نشود.

---

### ۱.۷ `useInsertionEffect`

```ts
useInsertionEffect(effect, deps?);
```

**هدف**

استایل‌های بحرانی را **قبل از** layout و نقاشی تزریق کنید، از FOUC (فلش محتوای بدون استایل) جلوگیری کنید.

**مثال – CSS پویا**

```tsx
useInsertionEffect(() => {
  const styleTag = document.createElement("style");
  styleTag.textContent = ".brand { color: tomato; }";
  document.head.append(styleTag);
  return () => styleTag.remove();
}, []);
```

**تمرین**

> کامپوننتی ایجاد کنید که یک رنگ accent تصادفی در mount انتخاب کند و قاعده‌ای مثل `.accent { color: <color>; }` تزریق کند.

---

### ۱.۸ `useCallback` & ۱.۹ `useMemo`

- `useCallback(fn, deps)` یک **تابع memoized** برمی‌گرداند.
- `useMemo(factory, deps)` یک **مقدار memoized** برمی‌گرداند.

**چه زمانی استفاده کنیم**

- جلوگیری از محاسبات / بازسازی‌های گران‌قیمت که باعث re-render فرزندان می‌شوند.

**مثال – handlers پایدار**

```tsx
const addTodo = useCallback((text: string) => {
  setTodos((t) => [...t, { id: crypto.randomUUID(), text }]);
}, []);
```

**بهترین شیوه‌ها**

- پس از تأیید مشکلات عملکرد به سراغ آن‌ها بروید.
- آرایه‌های وابستگی را با بالا بردن مقادیر پایدار کوچک نگه دارید.

**تمرین – نمایش‌دهنده فیبوناچی**

> عدد فیبوناچی `n` را نشان دهید که `n` از یک ورودی می‌آید. محاسبه را memoize کنید تا فقط وقتی `n` تغییر می‌کند اجرا شود.

---

### ۱.۱۰ `useImperativeHandle`

```ts
useImperativeHandle(ref, createHandle, deps?);
```

**هدف**

یک زیرمجموعه کنترل شده از متدهای imperative را برای کامپوننت‌های والد آشکار کنید.

**مثال – API ورودی سفارشی**

```tsx
const FancyInput = forwardRef<HTMLInputElement, Props>((props, ref) => {
  const innerRef = useRef<HTMLInputElement>(null);
  useImperativeHandle(ref, () => ({
    focus: () => innerRef.current?.focus(),
    clear: () => innerRef.current && (innerRef.current.value = ""),
  }));
  return <input ref={innerRef} {...props} />;
});
```

**تمرین**

> کامپوننت `Stopwatch` با متدهای `start()`، `stop()`، `reset()` بسازید که از طریق `useImperativeHandle` آشکار می‌شوند.

---

### ۱.۱۱ `useDebugValue`

برچسب‌های قابل مشاهده در React DevTools اضافه کنید.

```ts
useDebugValue(value, formatFn?);
```

مثال:

```ts
useDebugValue(user, (u) => `کاربر: ${u.name}`);
```

---

## ۲. هوک‌های اضافی

### ۲.۱ `useId`

ID های منحصر به فرد تولید کنید که بین سرور و کلاینت مطابقت دارند.

```ts
const id = useId();
<label htmlFor={id}>نام</label>
<input id={id} />
```

### ۲.۲ `useSyncExternalStore`

در یک store خارجی با سازگاری در طول رندر همزمان اشتراک کنید.

```tsx
const time = useSyncExternalStore(subscribe, getSnapshot);
```

### ۲.۳ `useDeferredValue`

یک مقدار غیرضروری را تا زمانی که مرورگر بیکار است، به تعویق بیندازید.

```tsx
const deferred = useDeferredValue(value);
```

**تمرین – فیلتر لیست**

> جستجوی جستجو را به تعویق بیندازید تا UI لیست برای ورودی‌های طولانی پاسخگو بماند.

### ۲.۴ `useTransition`

یک transition کم‌اولویت شروع کنید.

```ts
const [isPending, startTransition] = useTransition();
```

مثال – جستجوی type-ahead که UI را قفل نمی‌کند.

---

## ۳. جدید در React ۱۹

React ۱۹ بر **فرم‌ها** و **تغییرات داده** تمرکز دارد، سه هوک جدید به علاوه تابع جدید `use()` را معرفی می‌کند.

### ۳.۱ `useOptimistic`

UI را **قبل از** تأیید سرور به‌طور خوش‌بینانه به‌روزرسانی کنید.

```tsx
const [optimisticTodos, addOptimisticTodo] = useOptimistic<Todo[], Todo>(
  todos,
  (state, newTodo) => [...state, { ...newTodo, optimistic: true }]
);

async function handleAdd(text: string) {
  addOptimisticTodo({ id: "temp", text });
  await saveTodo(text);
}
```

**تمرین – ورودی چت**

> پیام‌ها را فوراً با برچسب _خوش‌بینانه_ نشان دهید، سپس پس از ذخیره جایگزین کنید.

### ۳.۲ `useActionState`

فرم `action` ها را مدیریت کنید و حالت کامپوننت را با نتیجه به‌روزرسانی کنید.

```tsx
const [error, formAction, pending] = useActionState(async (prev, formData) => {
  try {
    await submit(formData);
    return null; // خطایی نیست
  } catch (e) {
    return (e as Error).message;
  }
}, null);

<form action={formAction}>{/* ورودی‌ها */}</form>;
```

**تمرین – تغییر نام پروفایل**

> فرم تغییر نام پروفایل بسازید که خطاهای سمت سرور را از طریق `error` گزارش دهد.

### ۳.۳ `useFormStatus`

وضعیت نزدیک‌ترین `<form>` والد را بخوانید.

```tsx
const { pending } = useFormStatus();
<button disabled={pending}>ذخیره</button>;
```

**تمرین – غیرفعال در submit**

> در فرم تغییر نام بالا، دکمه submit را در حالی که `pending` true است غیرفعال کنید.

### ۳.۴ `use()`

اگرچه از نظر فنی یک هوک نیست، `use()` به شما اجازه می‌دهد _await_ promise ها را درون یک کامپوننت در طول رندر انجام دهید.

```tsx
function User({ id }: { id: string }) {
  const user = use(fetch(`/api/users/${id}`).then((r) => r.json()));
  return <span>{user.name}</span>;
}
```

**هشدارها**

- فقط در **Server Components** یا با کامپایلر React پشتیبانی می‌شود.
- یک promise زیر هود پرتاب می‌کند – به مرزهای Suspense تکیه کنید.

---

## ۴. واژه‌نامه و منابع بیشتر

- [پست انتشار React ۱۹](https://react.dev/blog/2024/12/05/react-19)
- [مرجع رسمی API هوک‌ها](https://react.dev/reference/react)
- [Kent C. Dodds – Epic React](https://epicreact.dev/) – غور عمیق و تمرینات
- [React Docs – فرم‌ها و Actions](https://react.dev/learn/forms)
