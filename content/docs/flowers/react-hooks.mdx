---
title: کتاب آشپزی هوک‌های React 19
description: مرجع عملی و مثال‌محور برای تمام هوک‌های رسمی React 19 با بهترین شیوه‌ها و تمرینات عملی.
---

# هوک‌های React 19

> **هوک‌ها چیستند؟** هوک‌ها فقط توابع JavaScript هستند که نامشان با `use*` شروع می‌شود. آن‌ها به شما اجازه می‌دهند تا به ویژگی‌های React از کامپوننت‌های تابعی "متصل شوید".

---

## ۱. هوک‌های بنیادی

این هوک‌ها بیشتر نیازهای روزانه را پوشش می‌دهند.

### ۱.۱ `useState`

تصور کنید کامپوننت شما یک **کوزه پس‌انداز** 🐷 است که یک عدد را درون خود نگه می‌دارد.
`useState` به شما **دو چیز** می‌دهد:

۱. **عدد فعلی** در کوزه پس‌انداز (`count`).
۲. یک **ربات دوستانه** به نام `setCount` که می‌تواند آن عدد را تغییر دهد.

دو راه برای گفتن به ربات که چه کاری انجام دهد:

| راه                  | آنچه می‌گویید          | معنای آن                                                                                               |
| -------------------- | ---------------------- | ------------------------------------------------------------------------------------------------------ |
| **مقدار مستقیم**     | `setCount(count + 1)`  | "هی ربات، این عدد دقیق را در کوزه پس‌انداز بنویس."                                                     |
| **تابع به‌روزرسانی** | `setCount(c => c + 1)` | "هی ربات، وقتی کوزه پس‌انداز را می‌گیری، ۱ را به هر عددی که در آنجا **درست در آن لحظه** است اضافه کن." |

چرا راه دوم امن‌تر است:

- **ربات از صف کار می‌کند.** اگر شما دستورات را دو بار خیلی سریع فریاد بزنید، هر دو دستور مقدار مستقیم ممکن است بر اساس همان عدد شروع باشند. فرم به‌روزرسانی باعث می‌شود ربات هر بار کوزه پس‌انداز را دوباره بررسی کند.
- **React گاهی منتظر می‌ماند** (آن را "دسته‌بندی" می‌کند) قبل از اینکه به ربات اجازه کار دهد. در طول آن انتظار، عدد می‌تواند تغییر کند. فرم به‌روزرسانی تضمین می‌کند که شما آن تغییرات را از دست ندهید.

> **قاعده کلی:**
> هر زمان که **مقدار جدید به مقدار قدیمی بستگی دارد**، از فرم به‌روزرسانی استفاده کنید.

---

مثال کوچک: یک دکمه **کلیک دوبل**:

```tsx
import { useState } from "react";

export default function DoubleClick() {
  const [count, setCount] = useState(0); // ۰ مقدار اولیه ما است

  const handleClick = () => {
    // ما می‌خواهیم هر کلیک +۲ باشد
    setCount((c) => c + 1);
    setCount((c) => c + 1);
  };

  return <button onClick={handleClick}>شما {count} بار کلیک کردید</button>;
}
```

- یک بار کلیک کنید → **۲**
- دوباره کلیک کنید → **۴**
  اگر ما از `setCount(count + 1)` دو بار استفاده کرده بودیم، فقط **۱ → ۲ → ۳ …** می‌گرفتیم (چون هر دو فراخوانی از همان `count` قدیمی استفاده می‌کنند).

---

این یک مثال برای ورودی‌های کنترل شده با useState است:

```tsx
const [query, setQuery] = useState<string>(""); // اگر undefined را به عنوان مقدار اولیه تنظیم کنیم چه اتفاقی می‌افتد؟

<input
  className="border p-1 rounded-sm"
  type="text"
  onChange={(e) => {
    setQuery(e.target.value.replace(/koala/gi, "🐨"));
  }}
/>;
```

---

راهنمای بهترین شیوه‌ها:

۱. **حالت را کوچک نگه دارید.** فقط آنچه را که نمی‌توانید محاسبه کنید ذخیره کنید.
۲. **از فرم تابعی (به‌روزرسانی) استفاده کنید** وقتی مقدار جدید به مقدار قدیمی بستگی دارد.
۳. **به‌روزرسانی‌های مرتبط را گروه‌بندی کنید** در یک فراخوانی:

```tsx
setUser((u) => ({ ...u, age: u.age + 1 }));
```

۴. **بلافاصله پس از فراخوانی `setX` حالت را نخوانید.** هنوز به‌روزرسانی نشده است.
۵. **برای حالت بسیار پیچیده** (تعداد زیادی فیلد)، `useReducer` را در نظر بگیرید.

---

تمرین خانگی 🏠

۱. **شمارنده تک‌مرحله‌ای**

- `Stepper.tsx` را بسازید.
- از **۰** شروع کنید.
- دکمه‌های **+۱**، **−۱**، و **بازنشانی** را اضافه کنید.
- از فرم به‌روزرسانی برای +۱ و −۱ استفاده کنید.

۲. **شمارنده ماشین زمان**

- دکمه دیگری **"+۵"** اضافه کنید که پنج بار با فرم به‌روزرسانی حلقه می‌زند

  ```tsx
  for (let i = 0; i < 5; i++) {
    setCount((c) => c + 1);
  }
  ```

- ثابت کنید که هر کلیک ۵ واحد می‌پرد.

۳. **آن را برای یک دوست توضیح دهید** (یا اردک لاستیکی 🦆)

- در یک پاراگراف کوتاه، توضیح دهید که **چرا** `setCount(c => c + 1)` از `setCount(count + 1)` امن‌تر است.
- اگر آن‌ها بتوانند آن را تکرار کنند، شما مفهوم را تسلط یافته‌اید!

کدگذاری شاد — و به یاد داشته باشید: **به ربات بگویید _چگونه_ مقدار را تغییر دهد، نه _چه_ مقداری بنویسد.**

- [اولین پروژه در کلاس - کتابخانه من](/docs/projects/hooks/use-state/first)
- [دومین پروژه در کلاس - لیست حیوانات خانگی](/docs/projects/hooks/use-state/second)

---

در اینجا یک **راهنمای آموزشی گام به گام** برای `useReducer` در React وجود دارد، نوشته شده به گونه‌ای که گویی من یک مبتدی را از دانش صفر آموزش می‌دهم — با توضیح واضح، بهترین شیوه‌ها، مثال‌های دنیای واقعی (مبتدی، متوسط، پیشرفته)، و یک تمرین خانگی در پایان.

---

### ۱.۲ `useReducer`

#### ۱.۲.۱ useReducer چیست؟

وقتی حالت کامپوننت شما **برای `useState` خیلی پیچیده می‌شود**، شما به چیزی بهتر برای سازماندهی منطق خود نیاز دارید.

✅ `useReducer` به شما اجازه می‌دهد **انتقالات حالت قابل پیش‌بینی** را با استفاده از یک تابع reducer بنویسید.
✅ شما یک "action" را "dispatch" می‌کنید، و reducer حالت جدید را محاسبه می‌کند.
✅ این بسیار شبیه Redux است، اما در React ساخته شده است.

---

#### ۱.۲.۲ نحو

```tsx
const [state, dispatch] = useReducer(reducer, initialArg, init?);
```

| اصطلاح       | معنی                                      |
| ------------ | ----------------------------------------- |
| `state`      | حالت فعلی                                 |
| `dispatch`   | تابعی که برای شروع تغییر فراخوانی می‌کنید |
| `reducer`    | تابع خالصی که حالت بعدی را تصمیم می‌گیرد  |
| `initialArg` | حالت اولیه                                |
| `init`       | مقداردهی اولیه تنبل اختیاری               |

---

#### ۱.۲.۳ چه زمانی از آن استفاده کنیم؟

- وقتی **منطق حالت پیچیده** دارید، مثلاً یک شیء یا چندین مقدار.
- وقتی **حالت بعدی به حالت قبلی بستگی دارد**.
- وقتی می‌خواهید **به‌روزرسانی‌های حالت را متمرکز کنید**، مثل یک Redux کوچک.

---

#### ۱.۲.۴ مثال مبتدی — شمارنده

این کلاسیک‌ترین و ساده‌ترین مثال است.

```tsx
type Action = { type: "inc" } | { type: "dec" } | { type: "reset" };

function reducer(state: number, action: Action) {
  switch (action.type) {
    case "inc":
      return state + 1;
    case "dec":
      return state - 1;
    case "reset":
      return 0;
    default:
      return state;
  }
}

function Counter() {
  const [count, dispatch] = useReducer(reducer, 0);

  return (
    <>
      <p>{count}</p>
      <button onClick={() => dispatch({ type: "inc" })}>+</button>
      <button onClick={() => dispatch({ type: "dec" })}>−</button>
      <button onClick={() => dispatch({ type: "reset" })}>بازنشانی</button>
    </>
  );
}
```

📝 یادداشت‌ها:

- `reducer` یک **تابع خالص** است → حالت `state` و `action` را می‌گیرد → **حالت جدید** را برمی‌گرداند.
- `dispatch` یک action را ارسال می‌کند.

---

#### ۱.۲.۵ بهترین شیوه‌ها

✅ reducer را **خالص** نگه دارید → هیچ فراخوانی API، تایمر، یا اثر جانبی.
✅ همیشه **تمام action ها** را مدیریت کنید.
✅ reducer را با کامپوننت هم‌مکان کنید مگر اینکه مشترک باشد.
✅ از TypeScript استفاده کنید تا مدیریت جامع action تضمین شود.
✅ حالت را تغییر ندهید — همیشه یک **کپی جدید** برگردانید.

---

#### ۱.۲.۶ مثال‌های دنیای واقعی

- **مبتدی** — `تغییر تم\*\*

```tsx
type ThemeAction = { type: "light" } | { type: "dark" };

function themeReducer(state: "light" | "dark", action: ThemeAction) {
  switch (action.type) {
    case "light":
      return "light";
    case "dark":
      return "dark";
    default:
      return state;
  }
}

function ThemeToggle() {
  const [theme, dispatch] = useReducer(themeReducer, "light");

  return (
    <div>
      <p>تم فعلی: {theme}</p>
      <button onClick={() => dispatch({ type: "light" })}>روشن</button>
      <button onClick={() => dispatch({ type: "dark" })}>تاریک</button>
    </div>
  );
}
```

---

- **متوسط** — `حالت فرم`

فرض کنید شما یک فرم با چندین فیلد را مدیریت می‌کنید:

```tsx
type FormState = { name: string; email: string };
type FormAction =
  | { type: "setName"; payload: string }
  | { type: "setEmail"; payload: string }
  | { type: "reset" };

function formReducer(state: FormState, action: FormAction): FormState {
  switch (action.type) {
    case "setName":
      return { ...state, name: action.payload };
    case "setEmail":
      return { ...state, email: action.payload };
    case "reset":
      return { name: "", email: "" };
    default:
      return state;
  }
}

function MyForm() {
  const [state, dispatch] = useReducer(formReducer, {
    name: "",
    email: "",
  });

  return (
    <form>
      <input
        value={state.name}
        onChange={(e) => dispatch({ type: "setName", payload: e.target.value })}
        placeholder="نام"
      />
      <input
        value={state.email}
        onChange={(e) =>
          dispatch({ type: "setEmail", payload: e.target.value })
        }
        placeholder="ایمیل"
      />
      <button type="button" onClick={() => dispatch({ type: "reset" })}>
        بازنشانی
      </button>
    </form>
  );
}
```

---

- **پیشرفته** — `سبد خرید`

یک سبد خرید تجارت الکترونیک را تصور کنید که می‌توانید موارد را اضافه، حذف، یا پاک کنید.

```tsx
type Item = { id: number; name: string };
type CartAction =
  | { type: "add"; item: Item }
  | { type: "remove"; id: number }
  | { type: "clear" };

function cartReducer(state: Item[], action: CartAction): Item[] {
  switch (action.type) {
    case "add":
      return [...state, action.item];
    case "remove":
      return state.filter((item) => item.id !== action.id);
    case "clear":
      return [];
    default:
      return state;
  }
}

function Cart() {
  const [cart, dispatch] = useReducer(cartReducer, []);

  return (
    <div>
      <button
        onClick={() =>
          dispatch({ type: "add", item: { id: Date.now(), name: "سیب" } })
        }
      >
        اضافه کردن سیب
      </button>
      <button onClick={() => dispatch({ type: "clear" })}>پاک کردن</button>
      <ul>
        {cart.map((item) => (
          <li key={item.id}>
            {item.name}{" "}
            <button onClick={() => dispatch({ type: "remove", id: item.id })}>
              حذف
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

---

#### ۱.۲.۷ تمرین خانگی

در اینجا برخی تمرینات دنیای واقعی برای تمرین شما وجود دارد.

- مبتدی

  ✅ یک **تغییر تم** با `light | dark | system` با استفاده از `useReducer` بسازید.
  ✅ ۳ دکمه برای تغییر بین این حالت‌ها رندر کنید.

- متوسط

  ✅ یک **فرم چندمرحله‌ای** بسازید (مثل ثبت‌نام چندمرحله‌ای).

  ✅ از `useReducer` برای پیگیری اینکه کاربر در کدام مرحله است، و داده‌های فرم استفاده کنید.

- پیشرفته

  ✅ یک **اپلیکیشن لیست کارها** بسازید:

      - اضافه کردن یک کار
      - تغییر وضعیت تکمیل شده
      - حذف یک کار
      - پاک کردن همه تکمیل شده‌ها

از `useReducer` برای مدیریت حالت استفاده کنید.

---

#### ۱.۲.۸ خلاصه

- `useReducer` مثل یک Redux کوچک برای یک کامپوننت واحد است.
- عالی برای **حالت پیچیده یا وابسته**.
- انتقالات حالت قابل پیش‌بینی و قابل آزمایش هستند.
- همیشه reducer خود را خالص نگه دارید!

---

### ۱.۳ `useContext`

**Context چیست؟** React Context به شما اجازه می‌دهد یک مقدار (هر داده JavaScript) را از طریق درخت کامپوننت خود بدون اینکه مجبور باشید props را به صورت دستی در هر سطح منتقل کنید، به اشتراک بگذارید. هوک `useContext` ساده‌ترین راه برای مصرف آن مقدار مشترک در یک کامپوننت تابعی است.

---

#### ۱.۳.۱ راهنمای گام به گام

۱. **ایجاد یک Context**

```ts
import { createContext } from "react";

export const MyContext = createContext<ContextType>(defaultValue);
```

- **پارامتر نوع**: شکل مقدار context را تعریف کنید.
- **مقدار پیش‌فرض**: فقط زمانی استفاده می‌شود که هیچ Provider مطابقی در بالا نباشد.

۲. **ارائه Context**

```tsx
import { MyContext } from "./MyContext";

function App() {
  const sharedValue: ContextType = {
    /* … */
  };

  return (
    <MyContext.Provider value={sharedValue}>
      <YourComponentTree />
    </MyContext.Provider>
  );
}
```

- قسمت‌هایی از درخت خود را که نیاز به دسترسی دارند، بپیچید.

۳. **مصرف با `useContext`**

```tsx
import { useContext } from "react";
import { MyContext } from "./MyContext";

function Child() {
  const ctx = useContext(MyContext);
  return <div>{/* از ctx اینجا استفاده کنید */}</div>;
}
```

۴. **اختیاری: ایجاد یک هوک سفارشی**
منطق را کپسوله کنید و DX را بهبود دهید:

```ts
export function useMyContext() {
  const ctx = useContext(MyContext);
  if (ctx === undefined) {
    throw new Error("useMyContext باید درون یک MyContext.Provider استفاده شود");
  }
  return ctx;
}
```

---

#### ۱.۳.۲ بهترین شیوه‌ها

- **از تغییرات مکرر برای به‌روزرسانی‌های سریع جلوگیری کنید**

  - داده‌های سریع‌التغییر (مثل موقعیت اسکرول) را در context قرار ندهید — از props یا حالت محلی استفاده کنید.

- **Context ها را بر اساس نگرانی تقسیم کنید**

  - به جای یک "mega-context"، context های جداگانه برای تم، احراز هویت، تنظیمات ایجاد کنید.

- **به صورت ایمن تایپ کنید**

  - همیشه یک مقدار پیش‌فرض خوب تایپ شده ارائه دهید یا در یک هوک سفارشی محافظت کنید.

---

#### ۱.۳.۳ مثال‌های دنیای واقعی

- مبتدی: تغییر تم

```tsx
// theme-context.tsx
import { createContext, useContext, useState } from "react";

type Theme = "light" | "dark";
const ThemeContext = createContext<{
  theme: Theme;
  toggle: () => void;
}>({ theme: "light", toggle: () => {} });

export function ThemeProvider({ children }: { children: React.ReactNode }) {
  const [theme, setTheme] = useState<Theme>("light");
  const toggle = () => setTheme((t) => (t === "light" ? "dark" : "light"));

  return (
    <ThemeContext.Provider value={{ theme, toggle }}>
      {children}
    </ThemeContext.Provider>
  );
}

export function useTheme() {
  return useContext(ThemeContext);
}

// App.tsx
import { ThemeProvider, useTheme } from "./theme-context";

function Toolbar() {
  const { theme, toggle } = useTheme();
  return (
    <button className={theme} onClick={toggle}>
      تغییر به {theme === "light" ? "تاریک" : "روشن"}
    </button>
  );
}

export default function App() {
  return (
    <ThemeProvider>
      <Toolbar />
    </ThemeProvider>
  );
}
```

---

- متوسط: تغییردهنده زبان

```tsx
// language-context.tsx
import { createContext, useContext, useState } from "react";

type Lang = "en" | "fa";
const LanguageContext = createContext<{
  lang: Lang;
  setLang: (l: Lang) => void;
}>({ lang: "en", setLang: () => {} });

export function LanguageProvider({ children }: { children: React.ReactNode }) {
  const [lang, setLang] = useState<Lang>("en");
  return (
    <LanguageContext.Provider value={{ lang, setLang }}>
      {children}
    </LanguageContext.Provider>
  );
}

export function useLanguage() {
  return useContext(LanguageContext);
}

// Greeting.tsx
import { useLanguage } from "./language-context";

export function Greeting() {
  const { lang } = useLanguage();
  return <h1>{lang === "en" ? "Hello" : "سلام"}</h1>;
}

// استفاده در App.tsx
import { LanguageProvider } from "./language-context";
import { Greeting } from "./Greeting";

function App() {
  return (
    <LanguageProvider>
      <Greeting />
      {/* یک انتخاب‌کننده جایی اضافه کنید */}
    </LanguageProvider>
  );
}
```

---

- پیشرفته: احراز هویت + دریافت داده + Memo

```tsx
// auth-context.tsx
import { createContext, useContext, useReducer, ReactNode } from "react";

interface User {
  id: string;
  name: string;
}

type State = { user: User | null };
type Action = { type: "LOGIN"; payload: User } | { type: "LOGOUT" };

const initialState: State = { user: null };

function authReducer(state: State, action: Action): State {
  switch (action.type) {
    case "LOGIN":
      return { user: action.payload };
    case "LOGOUT":
      return { user: null };
    default:
      return state;
  }
}

interface AuthContextType {
  user: User | null;
  login: (u: User) => void;
  logout: () => void;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: ReactNode }) {
  const [state, dispatch] = useReducer(authReducer, initialState);

  const login = (u: User) => {
    dispatch({ type: "LOGIN", payload: u });
  };

  const logout = () => {
    dispatch({ type: "LOGOUT" });
  };

  return (
    <AuthContext.Provider value={{ user: state.user, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const ctx = useContext(AuthContext);
  if (!ctx) {
    throw new Error("useAuth باید درون یک AuthProvider استفاده شود");
  }
  return ctx;
}
```

---

#### ۱.۳.۴ تمرین خانگی

۱. **مبتدی**

- یک `CounterContext` ایجاد کنید که یک عدد و یک تابع `increment()` را نگه می‌دارد.
- آن را در دو کامپوننت هم‌سطح مصرف کنید: یکی تعداد را نمایش می‌دهد، دیگری دکمه‌ای برای افزایش دارد.

۲. **متوسط**

- **تغییردهنده زبان** را گسترش دهید: یک dropdown برای انتخاب `en | fa | es` اضافه کنید، `Greeting` را برای مدیریت هر سه به‌روزرسانی کنید، و انتخاب را در `localStorage` ذخیره کنید.

۳. **پیشرفته**

- یک **AuthFlow** بسازید:

  ۱. `AuthContext` با `login`، `logout`، `user` ایجاد کنید.
  ۲. در ورود، یک پروفایل کاربر از یک API جعلی دریافت کنید.
  ۳. مسیرهای خاصی را محافظت کنید (از React Router استفاده کنید).
  ۴. اطمینان حاصل کنید که مقدار `AuthContext` memoized است.
  ۵. یک هوک سفارشی `useRequireAuth` اضافه کنید که اگر احراز هویت نشده باشد، redirect کند.

---

### ۱.۴ `useRef`

`useRef` یک هوک React است که به شما یک **مقدار قابل تغییر می‌دهد که در طول رندرها باقی می‌ماند اما باعث re-render نمی‌شود وقتی تغییر می‌کند.**

شما همچنین می‌توانید از آن برای گرفتن یک **مرجع به یک عنصر DOM** استفاده کنید، که رایج‌ترین مورد استفاده است.

---

#### ۱.۴.۱ نحو

```tsx
const ref = useRef<T | null>(initialValue);
```

اینجا:

- `T` نوع مقدار است (مثل `HTMLInputElement`، `number`، و غیره).
- `initialValue` معمولاً `null` است اگر با عناصر DOM کار می‌کنید.

---

#### ۱.۴.۲ چه زمانی استفاده کنیم

    ✅ وقتی نیاز دارید:

    - داده **قابل تغییر** را ذخیره کنید که **بر رندر کردن تأثیر نمی‌گذارد**.
    - دسترسی **مستقیم DOM** بگیرید (مثل فوکوس کردن یک ورودی، اسکرول کردن یک div، و غیره).

---

#### ۱.۴.۳ مثال مبتدی – فوکوس ورودی

یک مثال کلاسیک از دسترسی به یک عنصر DOM و فراخوانی متد `.focus()` آن.

```tsx
import { useRef } from "react";

function FocusInput() {
  const inputRef = useRef<HTMLInputElement>(null);

  const handleFocus = () => {
    inputRef.current?.focus();
  };

  return (
    <>
      <input ref={inputRef} />
      <button onClick={handleFocus}>فوکوس</button>
    </>
  );
}

export default FocusInput;
```

    **چه اتفاقی می‌افتد؟**

    ۱️⃣ در اولین رندر، `inputRef.current` برابر `null` است.
    ۲️⃣ پس از اینکه React `<input />` را رندر کرد، گره DOM را به `inputRef.current` اختصاص می‌دهد.
    ۳️⃣ کلیک کردن روی دکمه متد `.focus()` را روی آن گره DOM فراخوانی می‌کند.

---

#### ۱.۴.۴ بهترین شیوه‌ها

✅ از `useRef` استفاده کنید:

- برای دسترسی DOM (`inputRef`، `scrollRef`، و غیره).
- برای **مقادیر قابل تغییر** که نیازی به شروع re-render ندارند.

❌ از `useRef` برای موارد زیر استفاده نکنید:

- حالتی که بر آنچه در UI می‌بینید تأثیر می‌گذارد → به جای آن از `useState` استفاده کنید.

🎯 ref های DOM را با `null` مقداردهی اولیه کنید، و همیشه قبل از استفاده از آن‌ها با optional chaining (`?.`) بررسی کنید.

---

#### ۱.۴.۵ مثال متوسط — اسکرول به بالا

یک صفحه طولانی که می‌توانید به بالای آن اسکرول کنید.

```tsx
import { useRef } from "react";

function ScrollToTop() {
  const containerRef = useRef<HTMLDivElement>(null);

  const handleScrollTop = () => {
    containerRef.current?.scrollTo({ top: 0, behavior: "smooth" });
  };

  return (
    <div>
      <button onClick={handleScrollTop}>اسکرول به بالا</button>
      <div
        ref={containerRef}
        style={{
          height: "200px",
          overflow: "auto",
          border: "1px solid black",
          marginTop: "10px",
        }}
      >
        <div style={{ height: "800px" }}>
          <p>محتوای زیادی اینجا. به اسکرول کردن ادامه دهید...</p>
        </div>
      </div>
    </div>
  );
}

export default ScrollToTop;
```

---

#### ۱.۴.۶ مثال پیشرفته — ذخیره تاریخچه کلیک‌ها بدون Re-render

شما می‌توانید از `useRef` برای ذخیره داده **در طول رندرها** استفاده کنید، حتی اگر روی صفحه نمایش داده نشود، و باعث re-render نمی‌شود.

```tsx
import { useRef, useState } from "react";

function ClickHistory() {
  const [count, setCount] = useState(0);
  const historyRef = useRef<number[]>([]);

  const handleClick = () => {
    setCount((prev) => {
      const newCount = prev + 1;
      historyRef.current.push(newCount); // ذخیره در تاریخچه
      return newCount;
    });
  };

  const showHistory = () => {
    alert(`تاریخچه: ${historyRef.current.join(", ")}`);
  };

  return (
    <>
      <p>تعداد فعلی: {count}</p>
      <button onClick={handleClick}>افزایش</button>
      <button onClick={showHistory}>نمایش تاریخچه</button>
    </>
  );
}

export default ClickHistory;
```

---

چه اتفاقی می‌افتد؟

✅ هر بار که روی **افزایش** کلیک می‌کنید، `count` را افزایش می‌دهیم.
✅ در همان زمان، تعداد جدید را در آرایه `historyRef.current` ذخیره می‌کنیم.
✅ این تاریخچه **باعث** re-render نمی‌شود — فقط یک ذخیره‌سازی آرام است.
✅ وقتی روی **نمایش تاریخچه** فشار می‌دهید، تمام تعدادهای قبلی را نشان می‌دهد.

---

چرا این خوب است:

- شما یاد می‌گیرید که `useRef` چگونه داده را در طول رندرها نگه می‌دارد.
- نیازی به استفاده از `useEffect` ندارید.
- نشان می‌دهد که `useRef` _واکنشی نیست_ — فقط داده را آرام ذخیره می‌کند.

---

سناریوهای دنیای واقعی

✅ فوکوس کردن یک ورودی وقتی یک modal باز می‌شود.
✅ اسکرول کردن یک پنجره چت به پایین وقتی پیام جدیدی می‌رسد.
✅ ذخیره ID های interval یا تایمرها.
✅ اندازه‌گیری ابعاد عنصر با `getBoundingClientRect`.

---

#### ۱.۴.۷ جدول خلاصه

| ویژگی                           | `useRef`                            |
| ------------------------------- | ----------------------------------- |
| باعث رندر می‌شود؟               | ❌ خیر                              |
| عنصر DOM ذخیره می‌کند؟          | ✅ بله                              |
| مقادیر قابل تغییر ذخیره می‌کند؟ | ✅ بله                              |
| بهترین برای حالت UI؟            | ❌ خیر (از `useState` استفاده کنید) |

---

#### ۱.۴.۸ تمرین خانگی

- مبتدی:

  - یک فرم بسازید که کلیک کردن روی دکمه اولین فیلد خالی را فوکوس کند.

- متوسط:

  - یک `div` اسکرول‌شونده با موارد زیاد بسازید و دکمه‌ای برای اسکرول به پایین یا بالا به صورت نرم.

- پیشرفته:

  - کامپوننتی بسازید که موقعیت قبلی و فعلی ماوس را پیگیری کند، موقعیت قبلی را فقط از طریق `useRef` به‌روزرسانی کند.

---

#### ۱.۴.۹ خلاصه

✨ `useRef` عبارت است از:

- راهی برای نگه داشتن یک مقدار پایدار بدون اینکه باعث re-render شود.
- روش اصلی برای دسترسی به گره‌های DOM.

---

### ۱.۵ `useEffect`

#### ۱.۵.۱ useEffect دقیقاً چیه؟ (در یک نگاهِ تصویری)

وقتی رابط کاربری (UI) رندر می‌شود، گاهی لازم است کارهایی انجام دهیم که خارج از منطق داخلی React هستند. به این کارها **Side Effect** گفته می‌شود.

- **fetch** تعامل با api
- **setTimeout / setInterval** برای مدیریت زمان‌بندی
- **window\.addEventListener** برای گوش دادن به رخدادهای مرورگر
- **localStorage.setItem / getItem** برای ذخیره یا خواندن داده‌ها از حافظه مرورگر

تمام این کارها را باید با **`useEffect`** انجام دهیم.

<Mermaid
  chart="
sequenceDiagram
  autonumber
  participant R as 🖌️ Render()
  participant C as 📄 Commit (DOM)
  participant E as ⚡ useEffect(callback, deps)
  participant CL as 🧹 Cleanup (return)

R->>C: مرحله‌ی رندر و commit شدن UI
C->>E: اجرای useEffect (بعد از paint صفحه)
E-->>CL: برگرداندن تابع cleanup (اختیاری)
Note over E,CL: وقتی وابستگی‌ها تغییر کنند یا <br/>کامپوننت unmount شود
CL->>E: اجرای cleanup قبلی
E->>E: اجرای اثر جدید
"
/>

---

#### ۱.۵.۲ رفتار useEffect بسته به dependency array

- **وقتی آرایه خالی باشد: `[]`**

      - اثر (Effect) فقط **یک بار** بعد از mount شدن کامپوننت اجرا می‌شود.
      - در محیط **StrictMode**، React یک‌بار **اجرای اثر ← پاکسازی ← اجرای دوباره اثر** را شبیه‌سازی می‌کند.

این کار برای کمک به پیدا کردن باگ‌هاست و در نسخه‌ی نهایی (production) فقط یک‌بار اجرا خواهد شد.

- **وقتی وابستگی‌ها مشخص باشند: `[a, b]`**

  - اثر فقط وقتی دوباره اجرا می‌شود که **یکی از مقادیر `a` یا `b` تغییر کند**.
  - این حالت رایج‌ترین کاربرد `useEffect` است، چون دقیقاً کنترل می‌کنیم چه زمانی دوباره اجرا شود.

- **وقتی هیچ آرایه‌ای داده نشود: (بدون deps)**

- اثر بعد از **هر بار رندر شدن** کامپوننت اجرا می‌شود.
- استفاده از این حالت معمولاً توصیه نمی‌شود، چون می‌تواند باعث **حلقه‌ی بی‌نهایت** شود مگر این‌که دقیقاً بدانیم چه می‌کنیم.

---

**نکته‌ی مهم (Best Practice)**

برای اینکه فراموش نکنید تمام وابستگی‌ها را در آرایه قرار دهید، حتماً **قانون ESLint به نام `react-hooks/exhaustive-deps`** را فعال کنید. این قانون به‌طور خودکار به شما هشدار می‌دهد اگر چیزی را جا انداخته باشید.

---

#### ۱.۵.۳ مثال ۱ — آسان: همگام‌سازی عنوان صفحه با شمارنده

کاری که می‌خواهیم: وقتی عدد تغییر کرد، عنوان تب مرورگر هم به‌روز شود.

```tsx
import { useEffect, useState } from "react";

export default function CounterTitle() {
  const [count, setCount] = useState(0);

  // Effect: update the tab title whenever count changes
  useEffect(() => {
    document.title = `Counter: ${count}`;
  }, [count]); // ← Dependency: only when count changes

  return (
    <button onClick={() => setCount((c) => c + 1)}>Increase: {count}</button>
  );
}
```

**چرا درست است؟** چون ما در این اثر با «دنیای بیرون» (DOM سراسری: `document.title`) همگام می‌شویم و فقط به `count` نیاز داریم.

---

#### ۱.۵.۴ مثال ۲ — متوسط: جست‌وجوی دی‌بونس + درخواست شبکه با لغو

هدف: وقتی کاربر تایپ می‌کند، ۳۰۰ms صبر کنیم؛ اگر چیزی تایپ نشد، درخواست بزنیم؛ اگر کاربر عوض کرد/صفحه بسته شد، تایمر و درخواست قبلی **لغو** شوند.

```tsx
import { useEffect, useState } from "react";

type Item = { id: string; name: string };

export default function DebouncedSearch(): JSX.Element {
  const [query, setQuery] = useState(""); // user typing input
  const [debounced, setDebounced] = useState(""); // debounced value after 300ms
  const [data, setData] = useState<Item[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // 1) Debounce input
  useEffect(() => {
    const timer = setTimeout(() => setDebounced(query.trim()), 300);
    return () => clearTimeout(timer); // cleanup timer on input change/unmount
  }, [query]);

  // 2) Fetch when debounced value changes
  useEffect(() => {
    if (!debounced) {
      setData([]);
      setError(null);
      return;
    }

    const controller = new AbortController(); // to cancel request
    setLoading(true);
    setError(null);

    (async () => {
      try {
        const res = await fetch(
          `/api/search?q=${encodeURIComponent(debounced)}`,
          { signal: controller.signal }
        );
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const json: Item[] = await res.json();
        setData(json);
      } catch (e: unknown) {
        if ((e as any).name === "AbortError") return; // ignore if aborted
        setError((e as Error).message);
      } finally {
        setLoading(false);
      }
    })();

    return () => controller.abort(); // cancel request on dependency change/unmount
  }, [debounced]);

  return (
    <div className="space-y-2">
      <input
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="Search..."
        className="border p-2 rounded"
      />
      {loading && <p>Loading...</p>}
      {error && <p role="alert">Error: {error}</p>}
      <ul>
        {data.map((item) => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>
    </div>
  );
}
```

<Mermaid
  chart="
flowchart TD
  A[onChange] -->|update query| B[useEffect debounce]
  B -->|300ms| C[set debounced]
  C --> D[useEffect fetch]
  D -->|Abort on change/unmount| E[cleanup]
"
/>

**نکته‌های کلیدی**

- همیشه برای IO از **AbortController** یا روش لغوِ کتابخانهٔ خودت استفاده کن.
- اثرها باید **تحملِ راه‌اندازی دوباره** در توسعه را داشته باشند (StrictMode).

---

#### ۱.۵.۵ مثال ۳ — حرفه‌ای ولی قابل‌هضم: همگام‌سازی تم با localStorage + همگام‌سازی بین تب‌ها

این مثال هم حرفه‌ای است و هم ملموس: با کلیک کاربر، **تم (روشن/تاریک)** را ذخیره می‌کنیم و بین تب‌های بازِ مرورگر همگام نگه می‌داریم. علاوه بر آن، تم را روی **DOM خارج از React** هم اعمال می‌کنیم (side-effect واقعی).

```tsx
import { useEffect, useState } from "react";

// A small custom hook to keep state in localStorage and sync it across tabs
function useLocalStorageState<T>(key: string, initial: T) {
  // Lazily read the initial value from localStorage (to avoid SSR issues)
  const [value, setValue] = useState<T>(() => {
    try {
      const raw = localStorage.getItem(key);
      return raw ? (JSON.parse(raw) as T) : initial;
    } catch {
      return initial;
    }
  });

  // Side effect: whenever the value changes, write it to localStorage
  useEffect(() => {
    try {
      localStorage.setItem(key, JSON.stringify(value));
    } catch {}
  }, [key, value]);

  // Cross-tab synchronization: if another tab changes the value,
  // update this tab’s state as well
  useEffect(() => {
    const onStorage = (e: StorageEvent) => {
      if (e.key !== key) return;
      try {
        setValue(e.newValue ? (JSON.parse(e.newValue) as T) : initial);
      } catch {}
    };
    window.addEventListener("storage", onStorage);
    return () => window.removeEventListener("storage", onStorage);
  }, [key, initial]);

  return [value, setValue] as const;
}

export default function ThemeToggle() {
  const [theme, setTheme] = useLocalStorageState<"light" | "dark">(
    "theme",
    "light"
  );

  // Apply the theme directly to the DOM (outside React)
  useEffect(() => {
    // Alternatively, you could use classList instead
    document.documentElement.dataset.theme = theme;
  }, [theme]);

  return (
    <div>
      <p>Current theme: {theme}</p>
      <button
        onClick={() => setTheme((t) => (t === "light" ? "dark" : "light"))}
      >
        Switch to {theme === "light" ? "dark" : "light"}
      </button>
    </div>
  );
}
```

<Mermaid
  chart="
flowchart TD
  U[User Click] -->|setTheme| S[State تغییر می‌کند]
  S --> E1[Effect نوشتن در localStorage]
  E1 --> LS[(localStorage)]
  LS -->|storage event| E2[Effect لیسنر تب دیگر]
  S --> E3[Effect اعمال روی DOM]
  E3 --> D[document.documentElement]
"
/>

**چرا این الگو خوب است؟**

- دو اثرِ واضح و مستقل: یکی برای **نوشتن در localStorage**، یکی برای **لیسنر storage**.
- `cleanup` لیسنر را برمی‌دارد → **memory leak** نداریم.
- اعمال تم روی DOM نمونه‌ی واضحی از side-effect خارج از React است.

---

#### ۱.۵.۶ اشتباهات پرتکرار (و نسخهٔ کوتاهِ درمان)

- وابستگی ناقص (Missing Dependencies)

  - **مشکل:** اثر (effect) با **داده‌ی قدیمی** اجرا می‌شود چون همه‌ی متغیرهای لازم در آرایه‌ی وابستگی‌ها (`deps`) نیستند.

    هر چیزی را که داخل اثر استفاده می‌کنی باید در `deps` بنویسی. - اگر نمی‌خواهی مقدارش در هر تغییر باعث اجرای دوباره شود، از `useRef` یا یک **callback پایدار** (مثل `useCallback`) استفاده کن.

- نشت حافظه (Memory Leak)

  - **مشکل:** یک تایمر (`setInterval` / `setTimeout`)، لیسنر رویداد (`addEventListener`) یا درخواست async ایجاد کرده‌ای، اما در زمان مناسب پاک نمی‌شود. این کار باعث مصرف اضافه‌ی حافظه و باگ می‌شود.

    همیشه از `useEffect` یک **تابع پاکسازی** (`cleanup`) برگردان تا کارهای نیمه‌تمام را لغو یا پاک کند.

```js
useEffect(() => {
  const id = setInterval(tick, 1000);
  return () => clearInterval(id); // cleanup
}, []);
```

- حلقه‌ی بی‌انتها (Infinite Loop)

  - **مشکل:** داخل اثر `setState` صدا زده‌ای و همان state هم در `deps` وجود دارد → هر تغییر state دوباره effect را اجرا می‌کند → لوپ بی‌نهایت.

    - وابستگی را حذف نکن! این فقط مشکل را پنهان می‌کند.
    - به‌جای آن، **معماری کد** را تغییر بده یا یک **شرط/guard** بگذار تا فقط در شرایط خاص state را تغییر دهد.

- بسته‌ی کهنه (Stale Closure)

  - **مشکل:** اثر به state یا props قدیمی دسترسی دارد (به‌دلیل اینکه در زمان تعریف اثر، آن مقادیر گرفته شده‌اند).

    - آرایه‌ی وابستگی‌ها را کامل کن تا همیشه مقادیر تازه بیایند.
    - اگر فقط به آخرین مقدار نیاز داری، آن را در `useRef` نگه دار.
    - برای به‌روزرسانی state بر اساس مقدار قبلی، از فرم **تابعی** `setState` استفاده کن:

```js
setCount((prev) => prev + 1);
```

---

### ۱.۶ `useLayoutEffect`

**به صورت همزمان** پس از تغییرات DOM اما **قبل از** نقاشی مرورگر اجرا می‌شود.

**چه زمانی استفاده کنیم**

- اندازه‌گیری layout (مثل اندازه عنصر) **قبل از** اینکه کاربر فلیکر ببیند.

**مثال – اندازه‌گیری ارتفاع**

```tsx
const boxRef = useRef<HTMLDivElement>(null);
const [height, setHeight] = useState(0);

useLayoutEffect(() => {
  if (boxRef.current) {
    setHeight(boxRef.current.getBoundingClientRect().height);
  }
}, []);
```

**تمرین – هدر چسبان**

> ارتفاع یک هدر را اندازه‌گیری کنید و آن مقدار را به عنوان padding بالایی به محتوای اصلی اضافه کنید تا هرگز پشت هدر پنهان نشود.

---

### ۱.۷ `useInsertionEffect`

```ts
useInsertionEffect(effect, deps?);
```

**هدف**

استایل‌های بحرانی را **قبل از** layout و نقاشی تزریق کنید، از FOUC (فلش محتوای بدون استایل) جلوگیری کنید.

**مثال – CSS پویا**

```tsx
useInsertionEffect(() => {
  const styleTag = document.createElement("style");
  styleTag.textContent = ".brand { color: tomato; }";
  document.head.append(styleTag);
  return () => styleTag.remove();
}, []);
```

**تمرین**

> کامپوننتی ایجاد کنید که یک رنگ accent تصادفی در mount انتخاب کند و قاعده‌ای مثل `.accent { color: <color>; }` تزریق کند.

---

### ۱.۸ `useCallback` & ۱.۹ `useMemo`

- `useCallback(fn, deps)` یک **تابع memoized** برمی‌گرداند.
- `useMemo(factory, deps)` یک **مقدار memoized** برمی‌گرداند.

**چه زمانی استفاده کنیم**

- جلوگیری از محاسبات / بازسازی‌های گران‌قیمت که باعث re-render فرزندان می‌شوند.

**مثال – handlers پایدار**

```tsx
const addTodo = useCallback((text: string) => {
  setTodos((t) => [...t, { id: crypto.randomUUID(), text }]);
}, []);
```

**بهترین شیوه‌ها**

- پس از تأیید مشکلات عملکرد به سراغ آن‌ها بروید.
- آرایه‌های وابستگی را با بالا بردن مقادیر پایدار کوچک نگه دارید.

**تمرین – نمایش‌دهنده فیبوناچی**

> عدد فیبوناچی `n` را نشان دهید که `n` از یک ورودی می‌آید. محاسبه را memoize کنید تا فقط وقتی `n` تغییر می‌کند اجرا شود.

---

### ۱.۱۰ `useImperativeHandle`

```ts
useImperativeHandle(ref, createHandle, deps?);
```

**هدف**

یک زیرمجموعه کنترل شده از متدهای imperative را برای کامپوننت‌های والد آشکار کنید.

**مثال – API ورودی سفارشی**

```tsx
const FancyInput = forwardRef<HTMLInputElement, Props>((props, ref) => {
  const innerRef = useRef<HTMLInputElement>(null);
  useImperativeHandle(ref, () => ({
    focus: () => innerRef.current?.focus(),
    clear: () => innerRef.current && (innerRef.current.value = ""),
  }));
  return <input ref={innerRef} {...props} />;
});
```

**تمرین**

> کامپوننت `Stopwatch` با متدهای `start()`، `stop()`، `reset()` بسازید که از طریق `useImperativeHandle` آشکار می‌شوند.

---

### ۱.۱۱ `useDebugValue`

برچسب‌های قابل مشاهده در React DevTools اضافه کنید.

```ts
useDebugValue(value, formatFn?);
```

مثال:

```ts
useDebugValue(user, (u) => `کاربر: ${u.name}`);
```

---

## ۲. هوک‌های اضافی

### ۲.۱ `useId`

ID های منحصر به فرد تولید کنید که بین سرور و کلاینت مطابقت دارند.

```ts
const id = useId();
<label htmlFor={id}>نام</label>
<input id={id} />
```

### ۲.۲ `useSyncExternalStore`

در یک store خارجی با سازگاری در طول رندر همزمان اشتراک کنید.

```tsx
const time = useSyncExternalStore(subscribe, getSnapshot);
```

### ۲.۳ `useDeferredValue`

یک مقدار غیرضروری را تا زمانی که مرورگر بیکار است، به تعویق بیندازید.

```tsx
const deferred = useDeferredValue(value);
```

**تمرین – فیلتر لیست**

> جستجوی جستجو را به تعویق بیندازید تا UI لیست برای ورودی‌های طولانی پاسخگو بماند.

### ۲.۴ `useTransition`

یک transition کم‌اولویت شروع کنید.

```ts
const [isPending, startTransition] = useTransition();
```

مثال – جستجوی type-ahead که UI را قفل نمی‌کند.

---

## ۳. جدید در React ۱۹

React ۱۹ بر **فرم‌ها** و **تغییرات داده** تمرکز دارد، سه هوک جدید به علاوه تابع جدید `use()` را معرفی می‌کند.

### ۳.۱ `useOptimistic`

UI را **قبل از** تأیید سرور به‌طور خوش‌بینانه به‌روزرسانی کنید.

```tsx
const [optimisticTodos, addOptimisticTodo] = useOptimistic<Todo[], Todo>(
  todos,
  (state, newTodo) => [...state, { ...newTodo, optimistic: true }]
);

async function handleAdd(text: string) {
  addOptimisticTodo({ id: "temp", text });
  await saveTodo(text);
}
```

**تمرین – ورودی چت**

> پیام‌ها را فوراً با برچسب _خوش‌بینانه_ نشان دهید، سپس پس از ذخیره جایگزین کنید.

### ۳.۲ `useActionState`

فرم `action` ها را مدیریت کنید و حالت کامپوننت را با نتیجه به‌روزرسانی کنید.

```tsx
const [error, formAction, pending] = useActionState(async (prev, formData) => {
  try {
    await submit(formData);
    return null; // خطایی نیست
  } catch (e) {
    return (e as Error).message;
  }
}, null);

<form action={formAction}>{/* ورودی‌ها */}</form>;
```

**تمرین – تغییر نام پروفایل**

> فرم تغییر نام پروفایل بسازید که خطاهای سمت سرور را از طریق `error` گزارش دهد.

### ۳.۳ `useFormStatus`

وضعیت نزدیک‌ترین `<form>` والد را بخوانید.

```tsx
const { pending } = useFormStatus();
<button disabled={pending}>ذخیره</button>;
```

**تمرین – غیرفعال در submit**

> در فرم تغییر نام بالا، دکمه submit را در حالی که `pending` true است غیرفعال کنید.

### ۳.۴ `use()`

اگرچه از نظر فنی یک هوک نیست، `use()` به شما اجازه می‌دهد _await_ promise ها را درون یک کامپوننت در طول رندر انجام دهید.

```tsx
function User({ id }: { id: string }) {
  const user = use(fetch(`/api/users/${id}`).then((r) => r.json()));
  return <span>{user.name}</span>;
}
```

**هشدارها**

- فقط در **Server Components** یا با کامپایلر React پشتیبانی می‌شود.
- یک promise زیر هود پرتاب می‌کند – به مرزهای Suspense تکیه کنید.

---

## ۴. واژه‌نامه و منابع بیشتر

- [پست انتشار React ۱۹](https://react.dev/blog/2024/12/05/react-19)
- [مرجع رسمی API هوک‌ها](https://react.dev/reference/react)
- [Kent C. Dodds – Epic React](https://epicreact.dev/) – غور عمیق و تمرینات
- [React Docs – فرم‌ها و Actions](https://react.dev/learn/forms)
