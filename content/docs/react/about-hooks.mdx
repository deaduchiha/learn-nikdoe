---
title: درباره‌ی هوک‌ها
icon: NotebookPen
description: "در این صفحه با مفهوم هوک‌های React، کاربرد آن‌ها و نحوه استفاده از آن‌ها در کامپوننت‌ ها آشنا می‌شوید."
---

- **۲۰۱۳**
  اولین نسخه‌های React منتشر شد. فقط **Class Component** می‌توانستند `state` و lifecycle داشته باشند.

- **۲۰۱۴–۲۰۱۷**
  Functional Component ها معرفی شدند اما خیلی ساده بودند؛ فقط props می‌گرفتند و JSX برمی‌گرداندند.
  مشکلی که پیش آمد:

  - اشتراک‌گذاری منطق (مثلاً fetch یا event handling) سخت بود.
  - کدها پر از HOC و Render Props می‌شد و خوانایی از بین می‌رفت.

- **۲۰۱۸ (React Conf)**
  تیم React هوک‌ها را معرفی کرد. ایده این بود که:

  - state و lifecycle مستقیم در Functional Components استفاده شوند.
  - منطق به شکل هوک‌های سفارشی قابل اشتراک‌گذاری باشد.

- **۲۰۱۹ (React 16.8)**
  هوک‌ها به‌طور رسمی وارد React شدند (`useState`, `useEffect`, `useContext`, …).
  جامعه شروع به مهاجرت از کلاس‌ها به فانکشن‌ها کرد.

- **۲۰۲۰ به بعد**
  تقریباً همه پروژه‌ها و کتابخانه‌ها بر پایه‌ی Functional Components و هوک‌ها ساخته می‌شوند.
  کلاس‌ها هنوز پشتیبانی می‌شوند اما به‌ندرت استفاده می‌شوند.

---

🔑 **جمع‌بندی:**
هوک‌ها در ۲۰۱۸ معرفی و در ۲۰۱۹ وارد React شدند تا state و lifecycle را به Functional Components بیاورند، اشتراک‌گذاری منطق را ساده‌تر کنند و پیچیدگی کلاس‌ها و HOCها را کنار بزنند.

---

## 📊 جدول انواع هوک‌های پرکاربرد در React

| نام هوک                             | دسته‌بندی              | نیاز/کاربرد اصلی                                                                     |
| ----------------------------------- | ---------------------- | ------------------------------------------------------------------------------------ |
| **useState**                        | State Management       | نگهداری و به‌روزرسانی state محلی (مثل شمارنده، فرم، فیلترها)                         |
| **useReducer**                      | State Management       | مدیریت state پیچیده با الگوی reducer (جایگزین ساده‌ی برای لوکال)                     |
| **useContext**                      | Context                | دسترسی به داده‌ی Context بدون prop drilling (مثل theme، auth، language)              |
| **useRef**                          | References             | دسترسی مستقیم به یک عنصر DOM یا نگهداری یک مقدار mutable بدون re-render              |
| **useEffect**                       | Side Effects           | اجرای کارهای جانبی بعد از render (مثل fetch دیتا، event listener، تایمر)             |
| **useLayoutEffect**                 | Side Effects           | مشابه useEffect اما قبل از paint مرورگر اجرا می‌شود (برای هماهنگی DOM و اندازه‌گیری) |
| **useMemo**                         | Performance            | کش کردن نتیجه‌ی محاسبات سنگین برای جلوگیری از اجرای دوباره                           |
| **useCallback**                     | Performance            | کش کردن خود تابع برای جلوگیری از ایجاد تابع جدید در هر render (مخصوصاً برای props)   |
| **useImperativeHandle**             | Advanced / Forward Ref | کنترل کردن API‌یی که وقتی از forwardRef استفاده می‌کنی به parent داده می‌شود         |
| **useDebugValue**                   | Debugging              | نمایش اطلاعات سفارشی در React DevTools برای هوک‌های سفارشی                           |
| **useId** (از React 18)             | Accessibility / IDs    | تولید id یکتا در سمت سرور و کلاینت برای فرم‌ها یا المنت‌های مرتبط                    |
| **useTransition** (React 18)        | Concurrent Features    | مدیریت آپدیت‌های UI که می‌تواند عقب بیفتد (defer) بدون بلاک کردن تعاملات سریع        |
| **useDeferredValue** (React 18)     | Concurrent Features    | گرفتن یک نسخه‌ی "با تأخیر" از یک مقدار برای جلوگیری از کندی UI                       |
| **useSyncExternalStore** (React 18) | External Store         | اتصال ایمن به استورها و کتابخانه‌های مدیریت state خارجی (مثل Redux)                  |
| **useInsertionEffect** (React 18)   | Low-level              | اجرا قبل از تمام افکت‌ها برای درج استایل یا کارهای خیلی سطح پایین                    |

---

🔑 **خلاصه:**

- اگر **state ساده** داری → `useState`.
- اگر **state پیچیده** داری → `useReducer`.
- اگر **کار جانبی** داری (مثل fetch یا event) → `useEffect`.
- اگر **بهینه‌سازی کارایی** می‌خوای → `useMemo` و `useCallback`.
- اگر **داده مشترک بین لایه‌ها** داری → `useContext`.
- برای **پیشرفته‌ها و رندر همزمان** → `useTransition`, `useDeferredValue` و غیره.

---

---

### ۱.۶ `useLayoutEffect`

**به صورت همزمان** پس از تغییرات DOM اما **قبل از** نقاشی مرورگر اجرا می‌شود.

**چه زمانی استفاده کنیم**

- اندازه‌گیری layout (مثل اندازه عنصر) **قبل از** اینکه کاربر فلیکر ببیند.

**مثال – اندازه‌گیری ارتفاع**

```tsx
const boxRef = useRef<HTMLDivElement>(null);
const [height, setHeight] = useState(0);

useLayoutEffect(() => {
  if (boxRef.current) {
    setHeight(boxRef.current.getBoundingClientRect().height);
  }
}, []);
```

**تمرین – هدر چسبان**

> ارتفاع یک هدر را اندازه‌گیری کنید و آن مقدار را به عنوان padding بالایی به محتوای اصلی اضافه کنید تا هرگز پشت هدر پنهان نشود.

---

### ۱.۷ `useInsertionEffect`

```ts
useInsertionEffect(effect, deps?);
```

**هدف**

استایل‌های بحرانی را **قبل از** layout و نقاشی تزریق کنید، از FOUC (فلش محتوای بدون استایل) جلوگیری کنید.

**مثال – CSS پویا**

```tsx
useInsertionEffect(() => {
  const styleTag = document.createElement("style");
  styleTag.textContent = ".brand { color: tomato; }";
  document.head.append(styleTag);
  return () => styleTag.remove();
}, []);
```

**تمرین**

> کامپوننتی ایجاد کنید که یک رنگ accent تصادفی در mount انتخاب کند و قاعده‌ای مثل `.accent { color: <color>; }` تزریق کند.

---

### ۱.۸ `useCallback` & ۱.۹ `useMemo`

- `useCallback(fn, deps)` یک **تابع memoized** برمی‌گرداند.
- `useMemo(factory, deps)` یک **مقدار memoized** برمی‌گرداند.

**چه زمانی استفاده کنیم**

- جلوگیری از محاسبات / بازسازی‌های گران‌قیمت که باعث re-render فرزندان می‌شوند.

**مثال – handlers پایدار**

```tsx
const addTodo = useCallback((text: string) => {
  setTodos((t) => [...t, { id: crypto.randomUUID(), text }]);
}, []);
```

**بهترین شیوه‌ها**

- پس از تأیید مشکلات عملکرد به سراغ آن‌ها بروید.
- آرایه‌های وابستگی را با بالا بردن مقادیر پایدار کوچک نگه دارید.

**تمرین – نمایش‌دهنده فیبوناچی**

> عدد فیبوناچی `n` را نشان دهید که `n` از یک ورودی می‌آید. محاسبه را memoize کنید تا فقط وقتی `n` تغییر می‌کند اجرا شود.

---

### ۱.۱۰ `useImperativeHandle`

```ts
useImperativeHandle(ref, createHandle, deps?);
```

**هدف**

یک زیرمجموعه کنترل شده از متدهای imperative را برای کامپوننت‌های والد آشکار کنید.

**مثال – API ورودی سفارشی**

```tsx
const FancyInput = forwardRef<HTMLInputElement, Props>((props, ref) => {
  const innerRef = useRef<HTMLInputElement>(null);
  useImperativeHandle(ref, () => ({
    focus: () => innerRef.current?.focus(),
    clear: () => innerRef.current && (innerRef.current.value = ""),
  }));
  return <input ref={innerRef} {...props} />;
});
```

**تمرین**

> کامپوننت `Stopwatch` با متدهای `start()`، `stop()`، `reset()` بسازید که از طریق `useImperativeHandle` آشکار می‌شوند.

---

### ۱.۱۱ `useDebugValue`

برچسب‌های قابل مشاهده در React DevTools اضافه کنید.

```ts
useDebugValue(value, formatFn?);
```

مثال:

```ts
useDebugValue(user, (u) => `کاربر: ${u.name}`);
```

---

## ۲. هوک‌های اضافی

### ۲.۱ `useId`

ID های منحصر به فرد تولید کنید که بین سرور و کلاینت مطابقت دارند.

```ts
const id = useId();
<label htmlFor={id}>نام</label>
<input id={id} />
```

### ۲.۲ `useSyncExternalStore`

در یک store خارجی با سازگاری در طول رندر همزمان اشتراک کنید.

```tsx
const time = useSyncExternalStore(subscribe, getSnapshot);
```

### ۲.۳ `useDeferredValue`

یک مقدار غیرضروری را تا زمانی که مرورگر بیکار است، به تعویق بیندازید.

```tsx
const deferred = useDeferredValue(value);
```

**تمرین – فیلتر لیست**

> جستجوی جستجو را به تعویق بیندازید تا UI لیست برای ورودی‌های طولانی پاسخگو بماند.

### ۲.۴ `useTransition`

یک transition کم‌اولویت شروع کنید.

```ts
const [isPending, startTransition] = useTransition();
```

مثال – جستجوی type-ahead که UI را قفل نمی‌کند.

---

## ۳. جدید در React ۱۹

React ۱۹ بر **فرم‌ها** و **تغییرات داده** تمرکز دارد، سه هوک جدید به علاوه تابع جدید `use()` را معرفی می‌کند.

### ۳.۱ `useOptimistic`

UI را **قبل از** تأیید سرور به‌طور خوش‌بینانه به‌روزرسانی کنید.

```tsx
const [optimisticTodos, addOptimisticTodo] = useOptimistic<Todo[], Todo>(
  todos,
  (state, newTodo) => [...state, { ...newTodo, optimistic: true }]
);

async function handleAdd(text: string) {
  addOptimisticTodo({ id: "temp", text });
  await saveTodo(text);
}
```

**تمرین – ورودی چت**

> پیام‌ها را فوراً با برچسب _خوش‌بینانه_ نشان دهید، سپس پس از ذخیره جایگزین کنید.

### ۳.۲ `useActionState`

فرم `action` ها را مدیریت کنید و حالت کامپوننت را با نتیجه به‌روزرسانی کنید.

```tsx
const [error, formAction, pending] = useActionState(async (prev, formData) => {
  try {
    await submit(formData);
    return null; // خطایی نیست
  } catch (e) {
    return (e as Error).message;
  }
}, null);

<form action={formAction}>{/* ورودی‌ها */}</form>;
```

**تمرین – تغییر نام پروفایل**

> فرم تغییر نام پروفایل بسازید که خطاهای سمت سرور را از طریق `error` گزارش دهد.

### ۳.۳ `useFormStatus`

وضعیت نزدیک‌ترین `<form>` والد را بخوانید.

```tsx
const { pending } = useFormStatus();
<button disabled={pending}>ذخیره</button>;
```

**تمرین – غیرفعال در submit**

> در فرم تغییر نام بالا، دکمه submit را در حالی که `pending` true است غیرفعال کنید.

### ۳.۴ `use()`

اگرچه از نظر فنی یک هوک نیست، `use()` به شما اجازه می‌دهد _await_ promise ها را درون یک کامپوننت در طول رندر انجام دهید.

```tsx
function User({ id }: { id: string }) {
  const user = use(fetch(`/api/users/${id}`).then((r) => r.json()));
  return <span>{user.name}</span>;
}
```

**هشدارها**

- فقط در **Server Components** یا با کامپایلر React پشتیبانی می‌شود.
- یک promise زیر هود پرتاب می‌کند – به مرزهای Suspense تکیه کنید.

---

## ۴. واژه‌نامه و منابع بیشتر

- [پست انتشار React ۱۹](https://react.dev/blog/2024/12/05/react-19)
- [مرجع رسمی API هوک‌ها](https://react.dev/reference/react)
- [Kent C. Dodds – Epic React](https://epicreact.dev/) – غور عمیق و تمرینات
- [React Docs – فرم‌ها و Actions](https://react.dev/learn/forms)
