---
title: درباره‌ی هوک‌ها
description: "در این صفحه با مفهوم هوک‌های React، کاربرد آن‌ها و نحوه استفاده از آن‌ها در کامپوننت‌ ها آشنا می‌شوید."
---

- **۲۰۱۳**
  اولین نسخه‌های React منتشر شد. فقط **Class Component** می‌توانستند `state` و lifecycle داشته باشند.

- **۲۰۱۴–۲۰۱۷**
  Functional Component ها معرفی شدند اما خیلی ساده بودند؛ فقط props می‌گرفتند و JSX برمی‌گرداندند.
  مشکلی که پیش آمد:

  - اشتراک‌گذاری منطق (مثلاً fetch یا event handling) سخت بود.
  - کدها پر از HOC و Render Props می‌شد و خوانایی از بین می‌رفت.

- **۲۰۱۸ (React Conf)**
  تیم React هوک‌ها را معرفی کرد. ایده این بود که:

  - state و lifecycle مستقیم در Functional Components استفاده شوند.
  - منطق به شکل هوک‌های سفارشی قابل اشتراک‌گذاری باشد.

- **۲۰۱۹ (React 16.8)**
  هوک‌ها به‌طور رسمی وارد React شدند (`useState`, `useEffect`, `useContext`, …).
  جامعه شروع به مهاجرت از کلاس‌ها به فانکشن‌ها کرد.

- **۲۰۲۰ به بعد**
  تقریباً همه پروژه‌ها و کتابخانه‌ها بر پایه‌ی Functional Components و هوک‌ها ساخته می‌شوند.
  کلاس‌ها هنوز پشتیبانی می‌شوند اما به‌ندرت استفاده می‌شوند.

---

🔑 **جمع‌بندی:**
هوک‌ها در ۲۰۱۸ معرفی و در ۲۰۱۹ وارد React شدند تا state و lifecycle را به Functional Components بیاورند، اشتراک‌گذاری منطق را ساده‌تر کنند و پیچیدگی کلاس‌ها و HOCها را کنار بزنند.

---

## 📊 جدول انواع هوک‌های پرکاربرد در React

| نام هوک                             | دسته‌بندی              | نیاز/کاربرد اصلی                                                                     |
| ----------------------------------- | ---------------------- | ------------------------------------------------------------------------------------ |
| **useState**                        | State Management       | نگهداری و به‌روزرسانی state محلی (مثل شمارنده، فرم، فیلترها)                         |
| **useReducer**                      | State Management       | مدیریت state پیچیده با الگوی reducer (جایگزین ساده‌ی Redux برای لوکال)               |
| **useContext**                      | Context                | دسترسی به داده‌ی Context بدون prop drilling (مثل theme، auth، language)              |
| **useEffect**                       | Side Effects           | اجرای کارهای جانبی بعد از render (مثل fetch دیتا، event listener، تایمر)             |
| **useLayoutEffect**                 | Side Effects           | مشابه useEffect اما قبل از paint مرورگر اجرا می‌شود (برای هماهنگی DOM و اندازه‌گیری) |
| **useRef**                          | References             | دسترسی مستقیم به یک عنصر DOM یا نگهداری یک مقدار mutable بدون re-render              |
| **useMemo**                         | Performance            | کش کردن نتیجه‌ی محاسبات سنگین برای جلوگیری از اجرای دوباره                           |
| **useCallback**                     | Performance            | کش کردن خود تابع برای جلوگیری از ایجاد تابع جدید در هر render (مخصوصاً برای props)   |
| **useImperativeHandle**             | Advanced / Forward Ref | کنترل کردن API‌یی که وقتی از forwardRef استفاده می‌کنی به parent داده می‌شود         |
| **useDebugValue**                   | Debugging              | نمایش اطلاعات سفارشی در React DevTools برای هوک‌های سفارشی                           |
| **useId** (از React 18)             | Accessibility / IDs    | تولید id یکتا در سمت سرور و کلاینت برای فرم‌ها یا المنت‌های مرتبط                    |
| **useTransition** (React 18)        | Concurrent Features    | مدیریت آپدیت‌های UI که می‌تواند عقب بیفتد (defer) بدون بلاک کردن تعاملات سریع        |
| **useDeferredValue** (React 18)     | Concurrent Features    | گرفتن یک نسخه‌ی "با تأخیر" از یک مقدار برای جلوگیری از کندی UI                       |
| **useSyncExternalStore** (React 18) | External Store         | اتصال ایمن به استورها و کتابخانه‌های مدیریت state خارجی (مثل Redux)                  |
| **useInsertionEffect** (React 18)   | Low-level              | اجرا قبل از تمام افکت‌ها برای درج استایل یا کارهای خیلی سطح پایین                    |

---

🔑 **خلاصه:**

- اگر **state ساده** داری → `useState`.
- اگر **state پیچیده** داری → `useReducer`.
- اگر **کار جانبی** داری (مثل fetch یا event) → `useEffect`.
- اگر **بهینه‌سازی کارایی** می‌خوای → `useMemo` و `useCallback`.
- اگر **داده مشترک بین لایه‌ها** داری → `useContext`.
- برای **پیشرفته‌ها و رندر همزمان** → `useTransition`, `useDeferredValue` و غیره.

---

### ۱.۳ `useContext`

**Context چیست؟** React Context به شما اجازه می‌دهد یک مقدار (هر داده JavaScript) را از طریق درخت کامپوننت خود بدون اینکه مجبور باشید props را به صورت دستی در هر سطح منتقل کنید، به اشتراک بگذارید. هوک `useContext` ساده‌ترین راه برای مصرف آن مقدار مشترک در یک کامپوننت تابعی است.

---

### ۱.۴ `useRef`

`useRef` یک هوک React است که به شما یک **مقدار قابل تغییر می‌دهد که در طول رندرها باقی می‌ماند اما باعث re-render نمی‌شود وقتی تغییر می‌کند.**

شما همچنین می‌توانید از آن برای گرفتن یک **مرجع به یک عنصر DOM** استفاده کنید، که رایج‌ترین مورد استفاده است.

---

#### ۱.۴.۱ نحو

```tsx
const ref = useRef<T | null>(initialValue);
```

اینجا:

- `T` نوع مقدار است (مثل `HTMLInputElement`، `number`، و غیره).
- `initialValue` معمولاً `null` است اگر با عناصر DOM کار می‌کنید.

---

#### ۱.۴.۲ چه زمانی استفاده کنیم

    ✅ وقتی نیاز دارید:

    - داده **قابل تغییر** را ذخیره کنید که **بر رندر کردن تأثیر نمی‌گذارد**.
    - دسترسی **مستقیم DOM** بگیرید (مثل فوکوس کردن یک ورودی، اسکرول کردن یک div، و غیره).

---

#### ۱.۴.۳ مثال مبتدی – فوکوس ورودی

یک مثال کلاسیک از دسترسی به یک عنصر DOM و فراخوانی متد `.focus()` آن.

```tsx
import { useRef } from "react";

function FocusInput() {
  const inputRef = useRef<HTMLInputElement>(null);

  const handleFocus = () => {
    inputRef.current?.focus();
  };

  return (
    <>
      <input ref={inputRef} />
      <button onClick={handleFocus}>فوکوس</button>
    </>
  );
}

export default FocusInput;
```

    **چه اتفاقی می‌افتد؟**

    ۱️⃣ در اولین رندر، `inputRef.current` برابر `null` است.
    ۲️⃣ پس از اینکه React `<input />` را رندر کرد، گره DOM را به `inputRef.current` اختصاص می‌دهد.
    ۳️⃣ کلیک کردن روی دکمه متد `.focus()` را روی آن گره DOM فراخوانی می‌کند.

---

#### ۱.۴.۴ بهترین شیوه‌ها

✅ از `useRef` استفاده کنید:

- برای دسترسی DOM (`inputRef`، `scrollRef`، و غیره).
- برای **مقادیر قابل تغییر** که نیازی به شروع re-render ندارند.

❌ از `useRef` برای موارد زیر استفاده نکنید:

- حالتی که بر آنچه در UI می‌بینید تأثیر می‌گذارد → به جای آن از `useState` استفاده کنید.

🎯 ref های DOM را با `null` مقداردهی اولیه کنید، و همیشه قبل از استفاده از آن‌ها با optional chaining (`?.`) بررسی کنید.

---

#### ۱.۴.۵ مثال متوسط — اسکرول به بالا

یک صفحه طولانی که می‌توانید به بالای آن اسکرول کنید.

```tsx
import { useRef } from "react";

function ScrollToTop() {
  const containerRef = useRef<HTMLDivElement>(null);

  const handleScrollTop = () => {
    containerRef.current?.scrollTo({ top: 0, behavior: "smooth" });
  };

  return (
    <div>
      <button onClick={handleScrollTop}>اسکرول به بالا</button>
      <div
        ref={containerRef}
        style={{
          height: "200px",
          overflow: "auto",
          border: "1px solid black",
          marginTop: "10px",
        }}
      >
        <div style={{ height: "800px" }}>
          <p>محتوای زیادی اینجا. به اسکرول کردن ادامه دهید...</p>
        </div>
      </div>
    </div>
  );
}

export default ScrollToTop;
```

---

#### ۱.۴.۶ مثال پیشرفته — ذخیره تاریخچه کلیک‌ها بدون Re-render

شما می‌توانید از `useRef` برای ذخیره داده **در طول رندرها** استفاده کنید، حتی اگر روی صفحه نمایش داده نشود، و باعث re-render نمی‌شود.

```tsx
import { useRef, useState } from "react";

function ClickHistory() {
  const [count, setCount] = useState(0);
  const historyRef = useRef<number[]>([]);

  const handleClick = () => {
    setCount((prev) => {
      const newCount = prev + 1;
      historyRef.current.push(newCount); // ذخیره در تاریخچه
      return newCount;
    });
  };

  const showHistory = () => {
    alert(`تاریخچه: ${historyRef.current.join(", ")}`);
  };

  return (
    <>
      <p>تعداد فعلی: {count}</p>
      <button onClick={handleClick}>افزایش</button>
      <button onClick={showHistory}>نمایش تاریخچه</button>
    </>
  );
}

export default ClickHistory;
```

---

چه اتفاقی می‌افتد؟

✅ هر بار که روی **افزایش** کلیک می‌کنید، `count` را افزایش می‌دهیم.
✅ در همان زمان، تعداد جدید را در آرایه `historyRef.current` ذخیره می‌کنیم.
✅ این تاریخچه **باعث** re-render نمی‌شود — فقط یک ذخیره‌سازی آرام است.
✅ وقتی روی **نمایش تاریخچه** فشار می‌دهید، تمام تعدادهای قبلی را نشان می‌دهد.

---

چرا این خوب است:

- شما یاد می‌گیرید که `useRef` چگونه داده را در طول رندرها نگه می‌دارد.
- نیازی به استفاده از `useEffect` ندارید.
- نشان می‌دهد که `useRef` _واکنشی نیست_ — فقط داده را آرام ذخیره می‌کند.

---

سناریوهای دنیای واقعی

✅ فوکوس کردن یک ورودی وقتی یک modal باز می‌شود.
✅ اسکرول کردن یک پنجره چت به پایین وقتی پیام جدیدی می‌رسد.
✅ ذخیره ID های interval یا تایمرها.
✅ اندازه‌گیری ابعاد عنصر با `getBoundingClientRect`.

---

#### ۱.۴.۷ جدول خلاصه

| ویژگی                           | `useRef`                            |
| ------------------------------- | ----------------------------------- |
| باعث رندر می‌شود؟               | ❌ خیر                              |
| عنصر DOM ذخیره می‌کند؟          | ✅ بله                              |
| مقادیر قابل تغییر ذخیره می‌کند؟ | ✅ بله                              |
| بهترین برای حالت UI؟            | ❌ خیر (از `useState` استفاده کنید) |

---

#### ۱.۴.۸ تمرین خانگی

- مبتدی:

  - یک فرم بسازید که کلیک کردن روی دکمه اولین فیلد خالی را فوکوس کند.

- متوسط:

  - یک `div` اسکرول‌شونده با موارد زیاد بسازید و دکمه‌ای برای اسکرول به پایین یا بالا به صورت نرم.

- پیشرفته:

  - کامپوننتی بسازید که موقعیت قبلی و فعلی ماوس را پیگیری کند، موقعیت قبلی را فقط از طریق `useRef` به‌روزرسانی کند.

---

#### ۱.۴.۹ خلاصه

✨ `useRef` عبارت است از:

- راهی برای نگه داشتن یک مقدار پایدار بدون اینکه باعث re-render شود.
- روش اصلی برای دسترسی به گره‌های DOM.

---

### ۱.۵ `useEffect`

#### ۱.۵.۱ useEffect دقیقاً چیه؟ (در یک نگاهِ تصویری)

وقتی رابط کاربری (UI) رندر می‌شود، گاهی لازم است کارهایی انجام دهیم که خارج از منطق داخلی React هستند. به این کارها **Side Effect** گفته می‌شود.

- **fetch** تعامل با api
- **setTimeout / setInterval** برای مدیریت زمان‌بندی
- **window\.addEventListener** برای گوش دادن به رخدادهای مرورگر
- **localStorage.setItem / getItem** برای ذخیره یا خواندن داده‌ها از حافظه مرورگر

تمام این کارها را باید با **`useEffect`** انجام دهیم.

<Mermaid
  chart="
sequenceDiagram
  autonumber
  participant R as 🖌️ Render()
  participant C as 📄 Commit (DOM)
  participant E as ⚡ useEffect(callback, deps)
  participant CL as 🧹 Cleanup (return)

R->>C: مرحله‌ی رندر و commit شدن UI
C->>E: اجرای useEffect (بعد از paint صفحه)
E-->>CL: برگرداندن تابع cleanup (اختیاری)
Note over E,CL: وقتی وابستگی‌ها تغییر کنند یا <br/>کامپوننت unmount شود
CL->>E: اجرای cleanup قبلی
E->>E: اجرای اثر جدید
"
/>

---

#### ۱.۵.۲ رفتار useEffect بسته به dependency array

- **وقتی آرایه خالی باشد: `[]`**

      - اثر (Effect) فقط **یک بار** بعد از mount شدن کامپوننت اجرا می‌شود.
      - در محیط **StrictMode**، React یک‌بار **اجرای اثر ← پاکسازی ← اجرای دوباره اثر** را شبیه‌سازی می‌کند.

این کار برای کمک به پیدا کردن باگ‌هاست و در نسخه‌ی نهایی (production) فقط یک‌بار اجرا خواهد شد.

- **وقتی وابستگی‌ها مشخص باشند: `[a, b]`**

  - اثر فقط وقتی دوباره اجرا می‌شود که **یکی از مقادیر `a` یا `b` تغییر کند**.
  - این حالت رایج‌ترین کاربرد `useEffect` است، چون دقیقاً کنترل می‌کنیم چه زمانی دوباره اجرا شود.

- **وقتی هیچ آرایه‌ای داده نشود: (بدون deps)**

- اثر بعد از **هر بار رندر شدن** کامپوننت اجرا می‌شود.
- استفاده از این حالت معمولاً توصیه نمی‌شود، چون می‌تواند باعث **حلقه‌ی بی‌نهایت** شود مگر این‌که دقیقاً بدانیم چه می‌کنیم.

---

**نکته‌ی مهم (Best Practice)**

برای اینکه فراموش نکنید تمام وابستگی‌ها را در آرایه قرار دهید، حتماً **قانون ESLint به نام `react-hooks/exhaustive-deps`** را فعال کنید. این قانون به‌طور خودکار به شما هشدار می‌دهد اگر چیزی را جا انداخته باشید.

---

#### ۱.۵.۳ مثال ۱ — آسان: همگام‌سازی عنوان صفحه با شمارنده

کاری که می‌خواهیم: وقتی عدد تغییر کرد، عنوان تب مرورگر هم به‌روز شود.

```tsx
import { useEffect, useState } from "react";

export default function CounterTitle() {
  const [count, setCount] = useState(0);

  // Effect: update the tab title whenever count changes
  useEffect(() => {
    document.title = `Counter: ${count}`;
  }, [count]); // ← Dependency: only when count changes

  return (
    <button onClick={() => setCount((c) => c + 1)}>Increase: {count}</button>
  );
}
```

**چرا درست است؟** چون ما در این اثر با «دنیای بیرون» (DOM سراسری: `document.title`) همگام می‌شویم و فقط به `count` نیاز داریم.

---

#### ۱.۵.۴ مثال ۲ — متوسط: جست‌وجوی دی‌بونس + درخواست شبکه با لغو

هدف: وقتی کاربر تایپ می‌کند، ۳۰۰ms صبر کنیم؛ اگر چیزی تایپ نشد، درخواست بزنیم؛ اگر کاربر عوض کرد/صفحه بسته شد، تایمر و درخواست قبلی **لغو** شوند.

```tsx
import { useEffect, useState } from "react";

type Item = { id: string; name: string };

export default function DebouncedSearch(): JSX.Element {
  const [query, setQuery] = useState(""); // user typing input
  const [debounced, setDebounced] = useState(""); // debounced value after 300ms
  const [data, setData] = useState<Item[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // 1) Debounce input
  useEffect(() => {
    const timer = setTimeout(() => setDebounced(query.trim()), 300);
    return () => clearTimeout(timer); // cleanup timer on input change/unmount
  }, [query]);

  // 2) Fetch when debounced value changes
  useEffect(() => {
    if (!debounced) {
      setData([]);
      setError(null);
      return;
    }

    const controller = new AbortController(); // to cancel request
    setLoading(true);
    setError(null);

    (async () => {
      try {
        const res = await fetch(
          `/api/search?q=${encodeURIComponent(debounced)}`,
          { signal: controller.signal }
        );
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const json: Item[] = await res.json();
        setData(json);
      } catch (e: unknown) {
        if ((e as any).name === "AbortError") return; // ignore if aborted
        setError((e as Error).message);
      } finally {
        setLoading(false);
      }
    })();

    return () => controller.abort(); // cancel request on dependency change/unmount
  }, [debounced]);

  return (
    <div className="space-y-2">
      <input
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="Search..."
        className="border p-2 rounded"
      />
      {loading && <p>Loading...</p>}
      {error && <p role="alert">Error: {error}</p>}
      <ul>
        {data.map((item) => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>
    </div>
  );
}
```

<Mermaid
  chart="
flowchart TD
  A[onChange] -->|update query| B[useEffect debounce]
  B -->|300ms| C[set debounced]
  C --> D[useEffect fetch]
  D -->|Abort on change/unmount| E[cleanup]
"
/>

**نکته‌های کلیدی**

- همیشه برای IO از **AbortController** یا روش لغوِ کتابخانهٔ خودت استفاده کن.
- اثرها باید **تحملِ راه‌اندازی دوباره** در توسعه را داشته باشند (StrictMode).

---

#### ۱.۵.۵ مثال ۳ — حرفه‌ای ولی قابل‌هضم: همگام‌سازی تم با localStorage + همگام‌سازی بین تب‌ها

این مثال هم حرفه‌ای است و هم ملموس: با کلیک کاربر، **تم (روشن/تاریک)** را ذخیره می‌کنیم و بین تب‌های بازِ مرورگر همگام نگه می‌داریم. علاوه بر آن، تم را روی **DOM خارج از React** هم اعمال می‌کنیم (side-effect واقعی).

```tsx
import { useEffect, useState } from "react";

// A small custom hook to keep state in localStorage and sync it across tabs
function useLocalStorageState<T>(key: string, initial: T) {
  // Lazily read the initial value from localStorage (to avoid SSR issues)
  const [value, setValue] = useState<T>(() => {
    try {
      const raw = localStorage.getItem(key);
      return raw ? (JSON.parse(raw) as T) : initial;
    } catch {
      return initial;
    }
  });

  // Side effect: whenever the value changes, write it to localStorage
  useEffect(() => {
    try {
      localStorage.setItem(key, JSON.stringify(value));
    } catch {}
  }, [key, value]);

  // Cross-tab synchronization: if another tab changes the value,
  // update this tab’s state as well
  useEffect(() => {
    const onStorage = (e: StorageEvent) => {
      if (e.key !== key) return;
      try {
        setValue(e.newValue ? (JSON.parse(e.newValue) as T) : initial);
      } catch {}
    };
    window.addEventListener("storage", onStorage);
    return () => window.removeEventListener("storage", onStorage);
  }, [key, initial]);

  return [value, setValue] as const;
}

export default function ThemeToggle() {
  const [theme, setTheme] = useLocalStorageState<"light" | "dark">(
    "theme",
    "light"
  );

  // Apply the theme directly to the DOM (outside React)
  useEffect(() => {
    // Alternatively, you could use classList instead
    document.documentElement.dataset.theme = theme;
  }, [theme]);

  return (
    <div>
      <p>Current theme: {theme}</p>
      <button
        onClick={() => setTheme((t) => (t === "light" ? "dark" : "light"))}
      >
        Switch to {theme === "light" ? "dark" : "light"}
      </button>
    </div>
  );
}
```

<Mermaid
  chart="
flowchart TD
  U[User Click] -->|setTheme| S[State تغییر می‌کند]
  S --> E1[Effect نوشتن در localStorage]
  E1 --> LS[(localStorage)]
  LS -->|storage event| E2[Effect لیسنر تب دیگر]
  S --> E3[Effect اعمال روی DOM]
  E3 --> D[document.documentElement]
"
/>

**چرا این الگو خوب است؟**

- دو اثرِ واضح و مستقل: یکی برای **نوشتن در localStorage**، یکی برای **لیسنر storage**.
- `cleanup` لیسنر را برمی‌دارد → **memory leak** نداریم.
- اعمال تم روی DOM نمونه‌ی واضحی از side-effect خارج از React است.

---

#### ۱.۵.۶ اشتباهات پرتکرار (و نسخهٔ کوتاهِ درمان)

- وابستگی ناقص (Missing Dependencies)

  - **مشکل:** اثر (effect) با **داده‌ی قدیمی** اجرا می‌شود چون همه‌ی متغیرهای لازم در آرایه‌ی وابستگی‌ها (`deps`) نیستند.

    هر چیزی را که داخل اثر استفاده می‌کنی باید در `deps` بنویسی. - اگر نمی‌خواهی مقدارش در هر تغییر باعث اجرای دوباره شود، از `useRef` یا یک **callback پایدار** (مثل `useCallback`) استفاده کن.

- نشت حافظه (Memory Leak)

  - **مشکل:** یک تایمر (`setInterval` / `setTimeout`)، لیسنر رویداد (`addEventListener`) یا درخواست async ایجاد کرده‌ای، اما در زمان مناسب پاک نمی‌شود. این کار باعث مصرف اضافه‌ی حافظه و باگ می‌شود.

    همیشه از `useEffect` یک **تابع پاکسازی** (`cleanup`) برگردان تا کارهای نیمه‌تمام را لغو یا پاک کند.

```js
useEffect(() => {
  const id = setInterval(tick, 1000);
  return () => clearInterval(id); // cleanup
}, []);
```

- حلقه‌ی بی‌انتها (Infinite Loop)

  - **مشکل:** داخل اثر `setState` صدا زده‌ای و همان state هم در `deps` وجود دارد → هر تغییر state دوباره effect را اجرا می‌کند → لوپ بی‌نهایت.

    - وابستگی را حذف نکن! این فقط مشکل را پنهان می‌کند.
    - به‌جای آن، **معماری کد** را تغییر بده یا یک **شرط/guard** بگذار تا فقط در شرایط خاص state را تغییر دهد.

- بسته‌ی کهنه (Stale Closure)

  - **مشکل:** اثر به state یا props قدیمی دسترسی دارد (به‌دلیل اینکه در زمان تعریف اثر، آن مقادیر گرفته شده‌اند).

    - آرایه‌ی وابستگی‌ها را کامل کن تا همیشه مقادیر تازه بیایند.
    - اگر فقط به آخرین مقدار نیاز داری، آن را در `useRef` نگه دار.
    - برای به‌روزرسانی state بر اساس مقدار قبلی، از فرم **تابعی** `setState` استفاده کن:

```js
setCount((prev) => prev + 1);
```

---

### ۱.۶ `useLayoutEffect`

**به صورت همزمان** پس از تغییرات DOM اما **قبل از** نقاشی مرورگر اجرا می‌شود.

**چه زمانی استفاده کنیم**

- اندازه‌گیری layout (مثل اندازه عنصر) **قبل از** اینکه کاربر فلیکر ببیند.

**مثال – اندازه‌گیری ارتفاع**

```tsx
const boxRef = useRef<HTMLDivElement>(null);
const [height, setHeight] = useState(0);

useLayoutEffect(() => {
  if (boxRef.current) {
    setHeight(boxRef.current.getBoundingClientRect().height);
  }
}, []);
```

**تمرین – هدر چسبان**

> ارتفاع یک هدر را اندازه‌گیری کنید و آن مقدار را به عنوان padding بالایی به محتوای اصلی اضافه کنید تا هرگز پشت هدر پنهان نشود.

---

### ۱.۷ `useInsertionEffect`

```ts
useInsertionEffect(effect, deps?);
```

**هدف**

استایل‌های بحرانی را **قبل از** layout و نقاشی تزریق کنید، از FOUC (فلش محتوای بدون استایل) جلوگیری کنید.

**مثال – CSS پویا**

```tsx
useInsertionEffect(() => {
  const styleTag = document.createElement("style");
  styleTag.textContent = ".brand { color: tomato; }";
  document.head.append(styleTag);
  return () => styleTag.remove();
}, []);
```

**تمرین**

> کامپوننتی ایجاد کنید که یک رنگ accent تصادفی در mount انتخاب کند و قاعده‌ای مثل `.accent { color: <color>; }` تزریق کند.

---

### ۱.۸ `useCallback` & ۱.۹ `useMemo`

- `useCallback(fn, deps)` یک **تابع memoized** برمی‌گرداند.
- `useMemo(factory, deps)` یک **مقدار memoized** برمی‌گرداند.

**چه زمانی استفاده کنیم**

- جلوگیری از محاسبات / بازسازی‌های گران‌قیمت که باعث re-render فرزندان می‌شوند.

**مثال – handlers پایدار**

```tsx
const addTodo = useCallback((text: string) => {
  setTodos((t) => [...t, { id: crypto.randomUUID(), text }]);
}, []);
```

**بهترین شیوه‌ها**

- پس از تأیید مشکلات عملکرد به سراغ آن‌ها بروید.
- آرایه‌های وابستگی را با بالا بردن مقادیر پایدار کوچک نگه دارید.

**تمرین – نمایش‌دهنده فیبوناچی**

> عدد فیبوناچی `n` را نشان دهید که `n` از یک ورودی می‌آید. محاسبه را memoize کنید تا فقط وقتی `n` تغییر می‌کند اجرا شود.

---

### ۱.۱۰ `useImperativeHandle`

```ts
useImperativeHandle(ref, createHandle, deps?);
```

**هدف**

یک زیرمجموعه کنترل شده از متدهای imperative را برای کامپوننت‌های والد آشکار کنید.

**مثال – API ورودی سفارشی**

```tsx
const FancyInput = forwardRef<HTMLInputElement, Props>((props, ref) => {
  const innerRef = useRef<HTMLInputElement>(null);
  useImperativeHandle(ref, () => ({
    focus: () => innerRef.current?.focus(),
    clear: () => innerRef.current && (innerRef.current.value = ""),
  }));
  return <input ref={innerRef} {...props} />;
});
```

**تمرین**

> کامپوننت `Stopwatch` با متدهای `start()`، `stop()`، `reset()` بسازید که از طریق `useImperativeHandle` آشکار می‌شوند.

---

### ۱.۱۱ `useDebugValue`

برچسب‌های قابل مشاهده در React DevTools اضافه کنید.

```ts
useDebugValue(value, formatFn?);
```

مثال:

```ts
useDebugValue(user, (u) => `کاربر: ${u.name}`);
```

---

## ۲. هوک‌های اضافی

### ۲.۱ `useId`

ID های منحصر به فرد تولید کنید که بین سرور و کلاینت مطابقت دارند.

```ts
const id = useId();
<label htmlFor={id}>نام</label>
<input id={id} />
```

### ۲.۲ `useSyncExternalStore`

در یک store خارجی با سازگاری در طول رندر همزمان اشتراک کنید.

```tsx
const time = useSyncExternalStore(subscribe, getSnapshot);
```

### ۲.۳ `useDeferredValue`

یک مقدار غیرضروری را تا زمانی که مرورگر بیکار است، به تعویق بیندازید.

```tsx
const deferred = useDeferredValue(value);
```

**تمرین – فیلتر لیست**

> جستجوی جستجو را به تعویق بیندازید تا UI لیست برای ورودی‌های طولانی پاسخگو بماند.

### ۲.۴ `useTransition`

یک transition کم‌اولویت شروع کنید.

```ts
const [isPending, startTransition] = useTransition();
```

مثال – جستجوی type-ahead که UI را قفل نمی‌کند.

---

## ۳. جدید در React ۱۹

React ۱۹ بر **فرم‌ها** و **تغییرات داده** تمرکز دارد، سه هوک جدید به علاوه تابع جدید `use()` را معرفی می‌کند.

### ۳.۱ `useOptimistic`

UI را **قبل از** تأیید سرور به‌طور خوش‌بینانه به‌روزرسانی کنید.

```tsx
const [optimisticTodos, addOptimisticTodo] = useOptimistic<Todo[], Todo>(
  todos,
  (state, newTodo) => [...state, { ...newTodo, optimistic: true }]
);

async function handleAdd(text: string) {
  addOptimisticTodo({ id: "temp", text });
  await saveTodo(text);
}
```

**تمرین – ورودی چت**

> پیام‌ها را فوراً با برچسب _خوش‌بینانه_ نشان دهید، سپس پس از ذخیره جایگزین کنید.

### ۳.۲ `useActionState`

فرم `action` ها را مدیریت کنید و حالت کامپوننت را با نتیجه به‌روزرسانی کنید.

```tsx
const [error, formAction, pending] = useActionState(async (prev, formData) => {
  try {
    await submit(formData);
    return null; // خطایی نیست
  } catch (e) {
    return (e as Error).message;
  }
}, null);

<form action={formAction}>{/* ورودی‌ها */}</form>;
```

**تمرین – تغییر نام پروفایل**

> فرم تغییر نام پروفایل بسازید که خطاهای سمت سرور را از طریق `error` گزارش دهد.

### ۳.۳ `useFormStatus`

وضعیت نزدیک‌ترین `<form>` والد را بخوانید.

```tsx
const { pending } = useFormStatus();
<button disabled={pending}>ذخیره</button>;
```

**تمرین – غیرفعال در submit**

> در فرم تغییر نام بالا، دکمه submit را در حالی که `pending` true است غیرفعال کنید.

### ۳.۴ `use()`

اگرچه از نظر فنی یک هوک نیست، `use()` به شما اجازه می‌دهد _await_ promise ها را درون یک کامپوننت در طول رندر انجام دهید.

```tsx
function User({ id }: { id: string }) {
  const user = use(fetch(`/api/users/${id}`).then((r) => r.json()));
  return <span>{user.name}</span>;
}
```

**هشدارها**

- فقط در **Server Components** یا با کامپایلر React پشتیبانی می‌شود.
- یک promise زیر هود پرتاب می‌کند – به مرزهای Suspense تکیه کنید.

---

## ۴. واژه‌نامه و منابع بیشتر

- [پست انتشار React ۱۹](https://react.dev/blog/2024/12/05/react-19)
- [مرجع رسمی API هوک‌ها](https://react.dev/reference/react)
- [Kent C. Dodds – Epic React](https://epicreact.dev/) – غور عمیق و تمرینات
- [React Docs – فرم‌ها و Actions](https://react.dev/learn/forms)
