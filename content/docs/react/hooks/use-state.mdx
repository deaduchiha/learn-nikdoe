---
title: ‍‍‍useState
icon: FolderKanban
description: "useState یکی از پرکاربردترین هوک React است که به شما اجازه می‌دهد در کامپوننت ها State تعریف و مدیریت کنید. با هر بار تغییر State، کامپوننت دوباره رندر می‌شود. این هوک ساده‌ترین راه برای افزودن داده‌های پویا و تعاملی به رابط کاربری است."
---

## 📖 مقدمه: چرا به State نیاز داریم؟

فرض کن یک وبسایت داری:

- وقتی کاربر روی **دکمه Like** کلیک می‌کند، عدد لایک‌ها باید زیاد شود.
- وقتی در **input سرچ** چیزی نوشته می‌شود، متن باید جایی ذخیره شود تا بعداً استفاده شود.
- وقتی **مود شب** فعال می‌شود، رنگ پس‌زمینه تغییر می‌کند.

این‌ها نمونه‌ای از **اطلاعات پویا** هستند. رابط کاربری فقط یک تصویر ثابت نیست، باید به رفتار کاربر واکنش نشان دهد. در React این حافظه‌ی پویا را **State** می‌نامیم.

---

## useState دقیقاً چه چیزی به ما می‌دهد؟

وقتی از `useState` استفاده می‌کنیم، انگار یک **کوزه حافظه** به کامپوننت می‌دهیم. این کوزه شامل دو چیز است:

1. **مقدار فعلی داخل کوزه** (مثلاً عدد لایک‌ها = `count`)
2. یک **دستیار وفادار** (`setCount`) که مسئول تغییر دادن محتویات کوزه است.

به جای اینکه مستقیم خودمان مقدار را تغییر دهیم، همیشه به دستیار می‌گوییم چه کاری انجام دهد.

---

## دو روش برای تغییر مقدار

| روش              | مثال                   | توضیح                                                                                                          |
| ---------------- | ---------------------- | -------------------------------------------------------------------------------------------------------------- |
| مقدار مستقیم     | `setCount(count + 1)`  | "الان همین مقدار را بردار، یکی اضافه کن و در کوزه بگذار."                                                      |
| تابع به‌روزرسانی | `setCount(c => c + 1)` | "هر وقت خواستی مقدار جدید را ذخیره کنی، اول دوباره نگاه کن دقیقاً الان چه عددی در کوزه است، بعد یکی اضافه کن." |

### چرا روش دوم مطمئن‌تر است؟

- React به محض صدا زدن `setX` مقدار را تغییر نمی‌دهد. ممکن است چند تغییر را **صف‌بندی** کرده و بعد یک‌جا اعمال کند.
- اگر چند بار پشت سر هم دستور بدهیم و از مقدار مستقیم استفاده کنیم، همه‌ی دستورات از همان مقدار قدیمی استفاده می‌کنند.
- فرم تابعی همیشه آخرین مقدار واقعی را در نظر می‌گیرد.

---

## مثال: شمارنده‌ی دوبل

```tsx
import { useState } from "react";

export default function DoubleClick() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount((c) => c + 1);
    setCount((c) => c + 1); // Each click increases by +2
  };

  return <button onClick={handleClick}>👍 {count}</button>;
}
```

نتیجه:

- کلیک اول عدد را به ۲ می‌رساند.
- کلیک دوم عدد را به ۴ می‌رساند.
- کلیک سوم عدد را به ۶ می‌رساند.

اگر به جای فرم تابعی از `setCount(count + 1)` استفاده می‌کردیم، نتیجه ۱، ۲، ۳ و ... می‌شد، چون هر بار بر اساس مقدار قبلی حساب می‌کرد.

---

## مثال واقعی: سیستم لایک یوتیوب 🎬

```tsx
function LikeButton() {
  const [likes, setLikes] = useState(0);
  const [isLiked, setIsLiked] = useState(false);

  const toggleLike = () => {
    setIsLiked((l) => !l);
    setLikes((l) => (isLiked ? l - 1 : l + 1));
  };

  return (
    <button onClick={toggleLike}>
      {isLiked ? "❤️" : "🤍"} {likes}
    </button>
  );
}
```

- بار اول کلیک: لایک اضافه می‌شود و آیکون قرمز می‌گردد.
- بار دوم کلیک: لایک کم می‌شود و آیکون سفید می‌گردد.

این همان چیزی است که در اپلیکیشن‌هایی مثل اینستاگرام یا یوتیوب می‌بینید.

---

## مثال کاربردی: فرم جستجو

```tsx
const [query, setQuery] = useState("");

<input
  type="text"
  value={query}
  onChange={(e) => setQuery(e.target.value)}
  placeholder="Search..."
/>

<p>🔎 شما جستجو کردید: {query}</p>
```

هر چیزی که در input تایپ شود، همان لحظه در state ذخیره می‌شود. چون state تغییر می‌کند، کامپوننت دوباره رندر می‌شود و مقدار جدید روی صفحه نمایش داده می‌شود.

---

## بهترین شیوه‌ها

✅ **State را کوچک نگه دارید**
اگر چیزی را می‌توان از روی props یا state دیگر محاسبه کرد، آن را دوباره در state ذخیره نکنید.

✅ **از فرم تابعی استفاده کنید**
هر زمان که مقدار جدید به مقدار قبلی وابسته است، همیشه از `setX(c => ...)` استفاده کنید.

✅ **به‌روزرسانی‌های مرتبط را ترکیب کنید**

```tsx
setUser((u) => ({ ...u, age: u.age + 1 }));
```

❌ **بلافاصله پس از setX مقدار جدید را نخوانید**
React ممکن است چند تغییر را با هم دسته‌بندی کند و مقدار بلافاصله در دسترس نباشد.

✅ **برای state پیچیده** (مثل فرم با فیلدهای زیاد) بهتر است از `useReducer` استفاده کنید.

---

## تمرین عملی

🏠 **تمرین ۱: شمارنده‌ی ساده**

- یک شمارنده با دکمه‌های +۱، −۱ و Reset پیاده‌سازی کنید.
- مقدار اولیه باید صفر باشد.
- برای افزایش و کاهش از فرم تابعی استفاده کنید.

🏠 **تمرین ۲: ماشین زمان ⏳**

- یک دکمه "+۵" اضافه کنید که با حلقه‌ی for پنج بار پشت سر هم `setCount(c => c + 1)` اجرا کند.
- مطمئن شوید که هر بار دقیقاً ۵ عدد اضافه می‌شود.

🏠 **تمرین ۳: حالت ورود/خروج**

- یک state به نام `isLoggedIn` تعریف کنید.
- اگر مقدار آن false باشد، دکمه‌ی "ورود" نمایش داده شود.
- اگر true باشد، متن "خوش آمدی" نشان داده شود.
- با کلیک روی دکمه وضعیت تغییر کند.

---

## 🎯 جمع‌بندی نهایی

- `useState` مثل یک دفترچه یادداشت کوچک برای هر کامپوننت است.
- با تغییر مقدار، React دوباره کامپوننت را اجرا می‌کند و UI تازه نمایش داده می‌شود.
- اگر مقدار جدید به مقدار قبلی وابسته است، همیشه از فرم تابعی استفاده کنید.
- این هوک ساده، از ساخت یک شمارنده‌ی ساده گرفته تا سیستم لایک و فرم ورود، پایه‌ی اصلی تعامل در React است.
