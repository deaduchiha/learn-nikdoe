---
title: ‍‍‍useRef
icon: Pointer
description: "useRef به شما یک مقدار پایدار در رندرهای مختلف می‌دهد که تغییرش باعث re-render نمی‌شود. پرکاربردترین استفاده‌ی آن گرفتن مرجع DOM (مثل فوکوس ورودی یا اسکرول) است، اما می‌تواند مثل یک کش نامرئی برای نگه داشتن داده‌های غیرواکنشی هم عمل کند."
---

## 📖 مقدمه: useRef شبیه به چه چیزی است؟

تصور کن یک **یادداشت چسبان کوچک (Post-it)** کنار مانیتور کامپوننتت داری:

- هر چیزی بنویسی، تا وقتی صفحه بازه همونجا می‌مونه.
- وقتی مقدارش رو عوض می‌کنی، هیچ‌کس غیر از خودت خبردار نمی‌شه.
- این تغییر باعث بازطراحی (re-render) UI نمی‌شود.

این یادداشت همون چیزی هست که `useRef` در React بهت می‌ده.

---

## نحو

```tsx
const ref = useRef<T | null>(initialValue);
```

- `T`: نوع مقداری که ذخیره می‌کنی (مثلاً `HTMLInputElement` یا `number`).
- `initialValue`: مقدار اولیه. برای عناصر DOM معمولاً `null`.

`ref.current` همیشه به مقدار ذخیره‌شده اشاره می‌کند.

---

## چه زمانی از useRef استفاده کنیم؟

✅ وقتی نیاز داری **داده‌ای قابل تغییر** ذخیره کنی بدون اینکه روی UI تأثیر بگذارد.
✅ وقتی نیاز به دسترسی مستقیم به **DOM** داری (فوکوس، اسکرول، اندازه‌گیری).
❌ وقتی تغییر مقدار باید روی UI نمایش داده شود (اون‌وقت `useState` لازمه).

---

## مثال ۱: فوکوس ورودی (مبتدی)

```tsx
import { useRef } from "react";

function FocusInput() {
  const inputRef = useRef<HTMLInputElement>(null);

  const handleFocus = () => {
    inputRef.current?.focus();
  };

  return (
    <>
      <input ref={inputRef} />
      <button onClick={handleFocus}>فوکوس</button>
    </>
  );
}
```

📌 چه می‌شود؟

1. در رندر اول، `inputRef.current = null`.
2. بعد از render، React گره DOM `<input>` را در `inputRef.current` می‌گذارد.
3. با کلیک روی دکمه، متد `.focus()` روی آن اجرا می‌شود.

---

## مثال ۲: اسکرول به بالا (متوسط)

```tsx
import { useRef } from "react";

function ScrollToTop() {
  const boxRef = useRef<HTMLDivElement>(null);

  return (
    <div>
      <button
        onClick={() => boxRef.current?.scrollTo({ top: 0, behavior: "smooth" })}
      >
        برو بالا ⬆️
      </button>
      <div
        ref={boxRef}
        style={{ height: "200px", overflow: "auto", border: "1px solid black" }}
      >
        <div style={{ height: "800px" }}>
          <p>محتوای طولانی... پایین بروید تا دکمه را تست کنید</p>
        </div>
      </div>
    </div>
  );
}
```

---

## مثال ۳: ذخیره تاریخچه بدون re-render (پیشرفته)

```tsx
import { useRef, useState } from "react";

function ClickHistory() {
  const [count, setCount] = useState(0);
  const historyRef = useRef<number[]>([]);

  const handleClick = () => {
    setCount((c) => {
      const newValue = c + 1;
      historyRef.current.push(newValue);
      return newValue;
    });
  };

  return (
    <>
      <p>شمارش: {count}</p>
      <button onClick={handleClick}>افزایش</button>
      <button onClick={() => alert(historyRef.current.join(", "))}>
        نمایش تاریخچه
      </button>
    </>
  );
}
```

📌 نکته: تاریخچه در `historyRef.current` ذخیره می‌شود، ولی چون تغییری در state ایجاد نمی‌کند، UI دوباره رندر نمی‌شود.

---

## کاربردهای واقعی

- فوکوس خودکار روی input وقتی modal باز می‌شود.
- اسکرول خودکار در یک لیست چت.
- ذخیره‌ی ID تایمر یا interval برای لغو بعدی.
- ذخیره مقادیر موقتی مثل موقعیت ماوس یا مقدار قبلی state.
- اندازه‌گیری عناصر DOM با `getBoundingClientRect`.

---

## بهترین شیوه‌ها

- برای مقادیری که به UI مربوط نیستند از `useRef` استفاده کنید.
- برای داده‌هایی که باید نمایش داده شوند یا تغییرشان UI را عوض کند از `useState` استفاده کنید.
- همیشه ref های DOM را با `null` مقداردهی اولیه کنید و قبل از استفاده بررسی کنید (`?.`).
- اگر value در Providerها یا props تغییر زیادی دارد، ref جای مناسبی نیست.

---

## جدول خلاصه

| ویژگی                       | useRef                           |
| --------------------------- | -------------------------------- |
| باعث re-render می‌شود؟      | ❌ خیر                           |
| نگه‌داری DOM؟               | ✅ بله                           |
| نگه‌داری مقادیر قابل تغییر؟ | ✅ بله                           |
| مناسب برای state UI؟        | ❌ خیر (از useState استفاده شود) |

---

## تمرین عملی

🏠 **تمرین ۱ (مبتدی)**
یک فرم بسازید که وقتی روی دکمه کلیک شد، اولین input خالی فوکوس شود.

🏠 **تمرین ۲ (متوسط)**
یک container اسکرول‌پذیر با آیتم‌های زیاد بسازید و دکمه‌هایی برای اسکرول نرم به بالا و پایین اضافه کنید.

🏠 **تمرین ۳ (پیشرفته)**
کامپوننتی بسازید که موقعیت ماوس را دنبال کند:

- موقعیت فعلی را در state ذخیره کن (تا نمایش داده شود).
- موقعیت قبلی را فقط در `useRef` نگه دار.
- هنگام حرکت ماوس، همزمان هر دو مقدار را در کنسول چاپ کن.

---

## 🎯 جمع‌بندی

- `useRef` مثل یک کش یا دفترچه یادداشت نامرئی برای کامپوننت است.
- تغییرش باعث re-render نمی‌شود، پس برای ذخیره‌ی مقادیر موقتی و مرجع‌های DOM عالی است.
- برای داده‌هایی که باید UI را عوض کنند از `useState` استفاده کنید.
- سناریوهای اصلی: فوکوس ورودی، اسکرول، تایمرها، ذخیره مقدار قبلی.
